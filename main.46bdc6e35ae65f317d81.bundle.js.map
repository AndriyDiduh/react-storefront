{"version":3,"file":"main.46bdc6e35ae65f317d81.bundle.js","sources":["webpack:///./src/model/ProductModelBase.js","webpack:///./src/utils/url.js","webpack:///./src/utils/state.js","webpack:///./src/NavTab.js","webpack:///./src/NavTabs.js","webpack:///./src/ExpandableSection.js","webpack:///./src/router/serviceWorker.js","webpack:///./src/Link.js","webpack:///./src/utils/dataProps.js","webpack:///./src/createTheme.js","webpack:///./src/FilterButton.js","webpack:///./src/ImageSwitcher.js","webpack:///./src/Menu.js","webpack:///./src/Skeleton.js","webpack:///./src/model/SearchModelBase.js"],"sourcesContent":["/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport { types, onPatch } from 'mobx-state-tree'\nimport SelectionModelBase from './SelectionModelBase'\n\nconst ProductModelBase = types\n  .model('ProductModelBase', {\n    id: types.identifier,\n    url: types.maybeNull(types.string),\n    name: types.maybeNull(types.string),\n    description: types.maybeNull(types.string),\n    size: types.maybeNull(SelectionModelBase),\n    color: types.maybeNull(SelectionModelBase),\n    quantity: types.optional(types.number, 1),\n    rating: types.maybeNull(types.number),\n    reviewCount: types.maybeNull(types.number),\n    basePrice: types.maybeNull(types.number),\n    brand: types.maybeNull(types.string),\n    images: types.array(types.string),\n    thumbnails: types.array(types.string),\n    thumbnail: types.maybeNull(types.string),\n    currencyCode: types.optional(types.string, 'USD'),\n    loadingImages: false,\n  })\n  .views(self => ({\n    shouldApplyPatchOnPop(patch) {\n      return patch.page === 'Product'\n    },\n    get price() {\n      const size = self.size && self.size.selected\n\n      if (size && size.price) {\n        return size.price\n      } else {\n        return self.basePrice\n      }\n    },\n  }))\n  .actions(self => ({\n    afterCreate() {\n      onPatch(self, patch => {\n        if (patch.path === '/color/selected') {\n          // fetch images when a new color is selected\n          self.fetchImages()\n        }\n      })\n    },\n\n    /**\n     * Updates the quantity and fires an analytics event\n     * @param {Number} quantity\n     */\n    setQuantity(q) {\n      self.quantity = q < 1 ? 1 : q\n    },\n    /**\n     * Get images for the selected color\n     */\n    fetchImages() {\n      const { pathname, search } = window.location\n      const selected = self.color.selected\n      self.loadingImages = true\n\n      if (selected) {\n        fetch(`${pathname}/images/${selected.id}.json${search}`)\n          .then(res => res.json())\n          .then(state => self.apply({ ...state, loadingImages: false }))\n          .catch(() => self.apply({ loadingImages: false }))\n      }\n    },\n    /**\n     * Update the images based on the response from the images handler\n     * @param {String[]} images\n     */\n    apply(state) {\n      Object.assign(self, state)\n    },\n  }))\n\nexport default ProductModelBase\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\n/**\n * Strips the protocol and hostname from the URL, returning a relative URL.\n * @param {String} url An absolute or relative URL\n * @return {String} A relative URL\n */\nexport function relativeURL(url) {\n  if (url == null) {\n    return null\n  } else {\n    url = url.replace(/^(https?:)?\\/\\/[^\\/]*/, '')\n    if (url.length === 0) url = '/'\n    return url\n  }\n}\n\nconst cleanProtocol = protocol => (protocol || '').replace(/:/, '')\n\n/**\n * Creates an absolute URL for the given URL\n * @param {String} url A relative URL\n * @param {LocationModel} currentLocation The current browser location\n * @return {String} An absolute URL\n */\nexport function absoluteURL(url, currentLocation) {\n  if (url == null) {\n    return null\n  } else if (currentLocation == null) {\n    return url\n  } else if (url.match(/^(mailto|tel):/)) {\n    return url\n  } else if (url.match(/^\\/\\//)) {\n    // URL with hostname but no protocol (starting with //)\n    return `${cleanProtocol(currentLocation.protocol)}:${url}`\n  } else if (!url.match(/^https?:/)) {\n    // relative URL\n    if (!url.match(/^\\//)) {\n      // URL is relative to current path\n      url = `${currentLocation.pathname}/${url}`\n    }\n\n    let { port } = currentLocation\n\n    if (port === '80' || port === '443') {\n      port = ''\n    } else {\n      port = ':' + port\n    }\n\n    return `${cleanProtocol(currentLocation.protocol)}://${currentLocation.hostname}${port}${url}`\n  } else {\n    return url\n  }\n}\n\n/**\n * Returns true if a URL can be navigated to on the client using history.push\n * @param {String} url The URL to check\n * @param {String} router The router\n * @return {Boolean}\n */\nexport function canUseClientSideNavigation(url, router) {\n  if (!url) return false\n\n  // return false for non-webpage links\n  if (url.match(/^(mailto|tel):/)) return false\n\n  // return false for hash links\n  if (url.match(/^#/)) return false\n\n  // return false for absolute URLs\n  if (url.match(/^(http|https)?:?\\/\\//)) return false\n\n  // check if there is a proxyUpstream handler on the corresponding route\n  if (router && router.willNavigateToUpstream(url)) return false\n\n  return true\n}\n","/**\n * @license\n * Copyright © 2017-2019 Moov Corporation.  All rights reserved.\n */\n/**\n * If the provided object is a string, returns a function that parses the string as JSON,\n * otherwise returns the provided object.\n * @param {String|Object} state\n * @return {Object|Function}\n */\nexport function lazyState(state) {\n  if (typeof state === 'string') {\n    return () => JSON.parse(state)\n  } else {\n    return state\n  }\n}\n\n/**\n * If the provided object is a string, parses it as JSON and returns the resulting object,\n * otherwise returns the provided object.\n * @param {*} state\n * @return {Object}\n */\nexport function parseState(state) {\n  if (typeof state === 'string') {\n    return JSON.parse(state)\n  } else {\n    return state\n  }\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component } from 'react'\nimport Track from './Track'\nimport Link from './Link'\nimport Tab from '@material-ui/core/Tab'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport { observer } from 'mobx-react'\nimport { lazyState } from './utils/state'\n\nexport const styles = theme => ({\n  root: {\n    height: '56px',\n    [theme.breakpoints.up('md')]: {\n      minWidth: '130px'\n    }\n  },\n  clickEl: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    zIndex: 1\n  },\n  label: {\n    whiteSpace: 'nowrap'\n  },\n  link: {\n    display: 'block',\n    height: '100%',\n    fontSize: theme.typography.body1.fontSize\n  },\n  menu: {\n    padding: `${theme.margins.container}px`\n  },\n  menuItem: {\n    padding: `1em ${theme.margins.container}px`\n  }\n})\n\n@withStyles(styles, { name: 'RSFNavTab' })\n@observer\nexport default class NavTab extends Component {\n\n  render() {\n    const { classes, state, url, prefetch, text, item } = this.props\n\n    return (\n      <Track event=\"topNavClicked\" item={item}>\n        <Link\n          state={lazyState(state)}\n          className={classes.link}\n          to={url}\n          prefetch={prefetch}\n          onClick={this.props.onClick}\n          anchorProps={{\n            onMouseEnter: this.onMouseEnter,\n            onMouseLeave: this.props.onMouseLeave,\n            \"data-th\": \"topNavClicked\"\n          }}\n        >\n          <Tab\n            className={classes.root}\n            label={text}\n            classes={{\n              label: classes.label\n            }}\n          />\n        </Link>\n      </Track>\n    )\n  }\n\n  onMouseEnter = (e) => {\n    this.props.onMouseEnter({\n      target: e.currentTarget,\n      menu: this.getMenu()\n    })\n  }\n\n  getMenu() {\n    const { children, item, classes, onItemClick } = this.props\n\n    if (children) {\n      return children\n    } else if (item.items && item.items.length) {\n      return  (\n        <div className={classes.menu}>\n          {item.items.map((item, i) => (\n            <div key={i} className={classes.menuItem}>\n              <Link to={item.url} onClick={onItemClick}>{item.text}</Link>\n            </div>\n          ))}\n        </div>\n      )\n    } else {\n      return null\n    }\n  }\n\n}","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component, Fragment } from 'react'\nimport { inject, observer } from 'mobx-react'\nimport PropTypes from 'prop-types'\nimport { types, getParent } from \"mobx-state-tree\"\nimport { MenuItemModel } from './Menu'\nimport TabsRow from './TabsRow'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport NavTab from './NavTab'\nimport { relativeURL } from './utils/url'\nimport { Fade, Paper, Popper, Hidden } from '@material-ui/core'\nimport { parseState } from './utils/state'\n\n/**\n * Scrollable navigation tabs for the top of the app. All extra props are spread to the \n * underlying Material UI Tabs element.  When a tab is clicked, the \"top_nav_clicked\" analytics\n * event is fired.\n */\nexport const styles = theme => ({\n  tabs: {\n    maxWidth: theme.maxWidth,\n    flex: 1,\n  },\n  root: {\n    zIndex: theme.zIndex.appBar - 1,\n    display: 'flex',\n    justifyContent: 'center',\n    position: 'relative',\n    borderRadius: 0,\n    '&::before': {\n      content: \"''\",\n      top: 0,\n      left: 0,\n      width: '15px',\n      height: 'calc(100% - 3px)',\n      position: 'absolute',\n      background: 'linear-gradient(to right, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.0) 100%)',\n      zIndex: 1,\n    },\n    '&::after': {\n      content: \"''\",\n      top: 0,\n      right: 0,\n      width: '15px',\n      height: 'calc(100% - 3px)',\n      position: 'absolute',\n      background: 'linear-gradient(to left, rgba(255, 255, 255, 1.0) 0%, rgba(255, 255, 255, 0.0) 100%)',\n      zIndex: 1,\n    }\n  },\n  menu: {\n    zIndex: theme.zIndex.appBar,\n  },\n  menuPaper: {\n    borderRadius: '0',\n    position: 'relative',\n    top: '1px'\n  }\n});\n\n@withStyles(styles, { name: 'RSFNavTabs' })\n@inject(({ app, history }) => ({ tabs: app.tabs, history }))\n@observer\nexport default class NavTabs extends Component {\n\n  static propTypes = {\n    classes: PropTypes.objectOf(PropTypes.string),\n\n    /**\n     * Controls the amount of drop shadow.\n     */\n    elevation: PropTypes.number\n  }\n\n  static defaultProps = {\n    elevation: 2\n  }\n\n  state = {\n    open: false,\n    menu: null,\n    anchorEl: null,\n    overTab: false,\n    overMenu: false\n  }\n\n  render() {\n    const { tabs, classes, staticContext, history, elevation, ...tabsProps } = this.props\n    const { menu, overTab, overMenu, anchorEl } = this.state\n    const open = overTab || overMenu\n\n    if (!tabs) return null\n\n    const { selected } = tabs\n\n    return (\n      <Fragment>\n        <Paper className={classes.root} elevation={elevation}>\n          <TabsRow\n            initialSelectedIdx={selected}\n            onTabChange={this.handleChange}\n            items={tabs.items}\n            tabRenderer={this.renderTab}\n            centered\n            classes={{\n              root: classes.tabs,\n              tab: classes.tab\n            }}\n            {...tabsProps}\n          />\n        </Paper>\n        { !menu ? null : (\n          <Hidden xsDown>\n            <Popper\n              className={classes.menu}\n              open={open}\n              anchorEl={anchorEl}\n              transition\n            >\n              {({ TransitionProps }) => (\n                <Fade {...TransitionProps} timeout={350}>\n                  <Paper \n                    onMouseEnter={this.onMenuEnter} \n                    onMouseLeave={this.onMenuLeave}\n                    className={classes.menuPaper}\n                  >\n                    { menu }\n                  </Paper>\n                </Fade>\n              )}\n            </Popper>\n          </Hidden>\n        )}\n      </Fragment>\n    )\n  }\n\n  renderTab = (item, i) => {\n    return (\n      <NavTab \n        {...item}\n        key={i} \n        item={item} \n        onMouseEnter={this.showMenu}\n        onMouseLeave={this.onTabLeave}\n        onItemClick={this.onItemClick}\n        onClick={this.onItemClick}\n      />\n    )\n  }\n\n  showMenu = ({ menu, target }) => {\n    this.setState({\n      overTab: true,\n      anchorEl: target,\n      menu\n    })\n  }\n\n  onMenuEnter = () => {\n    this.setState({ overMenu: true })\n  }\n\n  onMenuLeave = () => {\n    this.setState({ overMenu: false })\n  }\n\n  onTabLeave = () => {\n    this.setState({ overTab: false })\n  }\n\n  onItemClick = () => {\n    this.setState({ overTab: false, overMenu: false })\n  }\n\n  handleChange = (_event, newValue) => {\n    const { tabs, history } = this.props\n    const item = tabs.items[newValue]\n    const url = relativeURL(item.url)\n\n    if (history) {\n      history.push(url, parseState(item.state))\n    } else {\n      window.location.href = url\n    }\n  }\n\n}\n\nexport const TabsModel = types\n  .model(\"TabsModel\", {\n    items: types.array(MenuItemModel)\n  })\n  .views(self => ({\n    get selected() {\n      const { location } = getParent(self)\n      const url = location.pathname + location.search\n      const index = self.items.findIndex(item => item.url === url)\n      return index === -1 ? null : index\n    }\n  }))\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport classnames from 'classnames'\nimport ExpansionPanel from '@material-ui/core/ExpansionPanel'\nimport ExpansionPanelDetails from '@material-ui/core/ExpansionPanelDetails'\nimport ExpansionPanelSummary from '@material-ui/core/ExpansionPanelSummary'\nimport ExpandMoreIcon from '@material-ui/icons/ExpandMore'\nimport Typography from '@material-ui/core/Typography'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport AmpExpandableSection from './amp/AmpExpandableSection'\nimport { inject } from 'mobx-react';\nimport withTheme from '@material-ui/core/styles/withTheme'\n\nexport const styles = (theme) => ({\n  root: {\n    boxShadow: 'none',\n    borderBottom: `1px solid ${theme.palette.divider}`,\n    background: 'transparent',\n\n    '&::before': {\n      display: 'none'\n    },\n\n    '& > *:first-child': {\n      padding: '0',\n      minHeight: '0'\n    }\n  },\n\n  margins: {\n    padding: `0 ${theme.margins.container}px`,\n  },\n\n  caption: {\n    transition: 'opacity .2s linear'\n  },\n\n  expandedCaption: {\n    opacity: 0\n  },\n\n  largeTitle: {\n    fontSize: '18px',\n    fontWeight: 'bold',\n    color: '#444'\n  },\n\n  details: {\n    padding: 0\n  },\n\n  summary: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    '[aria-expanded=true] > &': {\n      margin: '12px 0 !important'\n    }\n  },\n\n  withCollapseIcon: {\n    transform: 'translateY(-50%) rotate(0deg) !important'\n  },\n\n  summaryIconWrap: {\n    right: `-${theme.margins.container}px`\n  },\n\n  expandedPanel: {\n    margin: 0\n  },\n\n  expandIcon: { },\n  collapseIcon: { }\n});\n\n@withStyles(styles, { name: 'RSFExpandableSection' })\n@withTheme()\n@inject(({ app }) => ({ amp: app.amp }))\nexport default class ExpandableSection extends Component {\n\n  static propTypes = {\n    /**\n     * The title for the header of the expandable section\n     */\n    title: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n    /**\n     * Text to display to the right of the heading\n     */\n    caption: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n\n    /**\n     * The icon to use for collapsed groups\n     */\n    ExpandIcon: PropTypes.func,\n\n    /**\n     * The icon to use for expanded groups\n     */\n    CollapseIcon: PropTypes.func,\n\n    /**\n     * Set to false to remove the default left and right margins. Defaults to `true`.\n     */\n    margins: PropTypes.bool,\n\n    /** \n     * Controls the expanded state.  Defaults to false\n     */\n    expanded: PropTypes.bool\n  }\n\n  static defaultProps = {\n    margins: true\n  }\n\n  static getDerivedStateFromProps({ expanded }) {\n    if (typeof expanded !== 'undefined') {\n      return { expanded }\n    } else {\n      return {}\n    }\n  }\n\n  constructor({ expanded, ExpandIcon, CollapseIcon, theme }) {\n    super()\n\n    this.ExpandIcon = ExpandIcon || theme.ExpandIcon || ExpandMoreIcon\n    this.CollapseIcon = CollapseIcon || theme.CollapseIcon || this.ExpandIcon\n  \n    this.state = {\t\n      expanded\t\n    }\n  }\n\n  render() {\n    let { amp, classes, theme, children = [], title, caption, expanded, ExpandIcon: ei, CollapseIcon: ci, margins, ...others } = this.props\n\n    const { ExpandIcon, CollapseIcon } = this\n\n    if (amp) {\n      return <AmpExpandableSection ExpandIcon={ExpandIcon} CollapseIcon={CollapseIcon} title={title}>{children}</AmpExpandableSection>\n    } else {\n      return (\n        <ExpansionPanel \n          classes={{ \n            root: classnames({\n              [classes.root]: true,\n              [classes.margins]: margins,\n              [classes.expandedPanel]: true\n            }) \n          }}\n          expanded={expanded} \n          {...others} \n          onChange={this.onChange}\n        >\n          <ExpansionPanelSummary \n            expandIcon={\n              this.state.expanded ? <CollapseIcon className={classes.collapseIcon}/> : <ExpandIcon className={classes.expandIcon}/>\n            } \n            classes={this.getSummaryClasses()}\n          >\n            <Typography variant=\"subtitle1\">{title}</Typography>\n            { caption && (\n              <Typography \n                variant=\"caption\" \n                className={classnames({\n                  [classes.caption]: true,\n                  [classes.expandedCaption]: expanded\n                })}\n              >\n                {caption}\n              </Typography> \n            )}\n          </ExpansionPanelSummary>\n          <ExpansionPanelDetails classes={{ root: classes.details }}>\n            {children}\n          </ExpansionPanelDetails>\n        </ExpansionPanel>\n      )\n    }\n\n  }\n\n  /**\n   * Gets the classes for the ExpansionPanelSummary\n   * Here we add a class to remove the rotate transform if we're using a \n   * separate icon for the collapse state.\n   */\n  getSummaryClasses() {\n    const { classes } = this.props\n\n    const result = {\n      content: classes.summary,\n      expandIcon: classes.summaryIconWrap\n    }\n\n    if (this.CollapseIcon !== this.ExpandIcon) {\n      result.expandIcon = classes.withCollapseIcon\n    }\n\n    return result\n  }\n\n  onChange = (e, expanded) => {\n    if (this.props.onChange) {\n      this.props.onChange(e, expanded)\n    }\n    this.setState({ expanded })\n  }\n\n}","/**\n * @license\n * Copyright © 2017-2019 Moov Corporation.  All rights reserved.\n */\n\n/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\n/**\n * Cache content using the service worker.  If content is not supplied, the service worker will fetch\n * the content from the server\n * @param {String} path The URI path of the request\n * @param {String} cacheData The data to cache\n */\nexport async function cache(path, cacheData) {\n  if (await waitForServiceWorkerController()) {\n    const { apiVersion } = window.moov\n\n    if (cacheData) {\n      navigator.serviceWorker.controller.postMessage({\n        action: 'cache-state',\n        path,\n        apiVersion,\n        cacheData,\n      })\n    } else {\n      navigator.serviceWorker.controller.postMessage({ action: 'cache-path', path, apiVersion })\n    }\n  }\n}\n\n/**\n * Prefetches and caches JSON for the specified path\n * @param {String} path A URL path for a page (without .json)\n */\nexport async function prefetchJsonFor(path, includeSSR) {\n  if (!path) {\n    return\n  }\n  if (path.startsWith('http')) {\n    const url = new URL(path)\n    cache(`${url.origin}${url.pathname}.json${url.search}`)\n  } else {\n    const url = new URL(`http://z.z${path}`)\n    cache(`${url.pathname}.json${url.search}`)\n  }\n  if (includeSSR) {\n    cache(path)\n  }\n}\n\n/**\n * Prefetches and caches SSR and JSON for the specified path\n * @param {String} path A URL path for a page (without .json)\n */\nexport function prefetch(path) {\n  cache(path)\n  prefetchJsonFor(path)\n}\n\n/**\n * Aborts all in progress prefetches.  Call this function to prevent prefetching from blocking\n * more important requests, like page navigation.\n */\nexport async function abortPrefetches() {\n  if (await waitForServiceWorkerController()) {\n    navigator.serviceWorker.controller.postMessage({ action: 'abort-prefetches' })\n  }\n}\n\n/**\n * Resume queued prefetch requests which were cancelled to allow for more important requests\n */\nexport async function resumePrefetches() {\n  if (await waitForServiceWorkerController()) {\n    navigator.serviceWorker.controller.postMessage({ action: 'resume-prefetches' })\n  }\n}\n\n/**\n * Configures runtime caching options\n * @param {Object} options\n * @param {Object} options.cacheName The name of the runtime cache\n * @param {Object} options.maxEntries The max number of entries to store in the cache\n * @param {Object} options.maxAgeSeconds The TTL in seconds for entries\n */\nexport async function configureCache(options) {\n  if (await waitForServiceWorkerController()) {\n    navigator.serviceWorker.controller.postMessage({ action: 'configure-runtime-caching', options })\n  }\n}\n\n/**\n * Resolves when the service worker has been installed\n */\nasync function waitForServiceWorkerController() {\n  if (!navigator.serviceWorker || !navigator.serviceWorker.controller) return false\n\n  return new Promise(resolve => {\n    navigator.serviceWorker.ready.then(() => {\n      if (navigator.serviceWorker.controller) {\n        return resolve(true)\n      }\n      navigator.serviceWorker.addEventListener('controllerchange', () => {\n        return resolve(true)\n      })\n    })\n  })\n}\n\n/**\n * Removes runtime caches for old versions of the api.  This ensures that all responses\n * are appropriate for the current version of the UI.\n */\nexport async function removeOldCaches() {\n  if (await waitForServiceWorkerController()) {\n    navigator.serviceWorker.controller.postMessage({\n      action: 'remove-old-caches',\n      apiVersion: window.moov.apiVersion,\n    })\n  }\n}\n\nexport default {\n  removeOldCaches,\n  waitForServiceWorkerController,\n  configureCache,\n  resumePrefetches,\n  abortPrefetches,\n  prefetch,\n  prefetchJsonFor,\n  cache,\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component } from 'react'\nimport { inject } from 'mobx-react'\nimport PropTypes from 'prop-types'\nimport { relativeURL, absoluteURL, canUseClientSideNavigation } from './utils/url'\nimport { prefetchJsonFor } from './router/serviceWorker'\nimport VisibilitySensor from 'react-visibility-sensor'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport classnames from 'classnames'\nimport dataProps from './utils/dataProps'\n\nexport const styles = {\n  root: {},\n};\n\n@withStyles(styles, { name: 'RSFLink' })\n@inject(({ history, router, app }) => ({ history, router, location: app.location }))\nexport default class Link extends Component {\n\n  prefetched = false\n\n  static propTypes = {\n    /**\n     * The path to navigate to when the link is clicked\n     */\n    to: PropTypes.string,\n\n    /**\n     * Data to assign to the history state\n     */\n    state: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),\n\n    /**\n     * Set to true to force server side navigation.  Defaults to false\n     */\n    server: PropTypes.bool,\n\n    /**\n     * Set to \"visible\" to prefetch linked page data when the link is scrolled into view.  \n     * Set to \"always\" to prefetch even when the link is hidden.\n     */\n    prefetch: PropTypes.oneOf(['always', 'visible']),\n\n    /**\n     * Set this prop to prefetch a URL other than the one specified in the to prop\n     */\n    prefetchURL: PropTypes.string,\n\n    /**\n     * A function to call when the link is clicked.\n     */\n    onClick: PropTypes.func,\n\n    /**\n     * Props to apply to the underlying html anchor element\n     */\n    anchorProps: PropTypes.object,\n\n    /**\n     * A function to call when the link becomes visible\n     */\n    onVisible: PropTypes.func,\n\n    /**\n     * A function to call when the link becomes visible for the first time.\n     * Use this event to track impressions.\n     */\n    onImpression: PropTypes.func\n  }\n\n  static defaultProps = {\n    anchorProps: {}\n  }\n\n  constructor() {\n    super()\n    this.onImpressionFired = false // keep track of when onVisible is fired so we only fire it once\n    this.el = React.createRef()\n  }\n\n  componentDidMount() {\n    if (this.props.prefetch === 'always') {\n      this.prefetch()\n    }\n  }\n\n  componentDidUpdate() {\n    if (this.prefetched !== this.urlToPrefetch()) {\n      // reset prefetched state if the prefetch url changes\n      this.prefetched = null\n    }\n  }\n\n  prefetch() {\n    const url = this.urlToPrefetch()\n\n    if (this.prefetched !== url) {\n      prefetchJsonFor(url)\n      this.prefetched = url\n    }\n  }\n\n  urlToPrefetch() {\n    return this.props.prefetchURL || this.props.to\n  }\n\n  render() {\n    const { anchorProps, className, style, children, prefetch, to, location, onVisible, onImpression, ...others } = this.props\n\n    const props = {\n      ...anchorProps,\n      ...dataProps(others),\n      'data-moov-link': 'on',\n      className: classnames(this.props.classes.root, className),\n      ref: this.el,\n      style,\n      onClick: this.onClick,\n      href: absoluteURL(to, location) // we always render absolute URLs for SEO purposes\n    }\n\n    if (prefetch) {\n      props['data-moov-rel'] = 'prefetch';\n    }\n\n    const link = <a {...props}>{children}</a>\n\n    if (prefetch === 'visible' || onVisible || onImpression) {\n      return (\n        <VisibilitySensor onChange={this.onVisibleChange} partialVisibility>\n          {link}\n        </VisibilitySensor>\n      )\n    } else {\n      return link\n    }\n  }\n\n  onVisibleChange = (visible) => {\n    const { prefetch, onVisible, onImpression } = this.props\n\n    if (visible) {\n      const el = this.el.current\n\n      // Will get here if the link is on a hidden page\n      // for some reason the visibility sensor fires for all links on a page right after \n      // that page has been hidden.  We check el.offsetParent to make sure the link is truly visible\n      // see https://stackoverflow.com/questions/19669786/check-if-element-is-visible-in-dom for more info on this method\n      if (el.offsetParent != null) {\n        if (prefetch === 'visible') {\n          this.prefetch()\n        }\n\n        if (onVisible) {\n          onVisible()\n        }\n\n        if (onImpression && !this.onImpressionFired) {\n          this.onImpressionFired = true\n          onImpression()\n        } \n      }\n    }\n  }\n\n  onClick = e => {\n    let { server, onClick, to, state, history } = this.props\n    \n    if (onClick) {\n      onClick(e)\n    }\n\n    if (typeof state === 'function') {\n      state = state()\n    }\n\n    const url = relativeURL(to)\n\n    if (!e.isDefaultPrevented() && !server && canUseClientSideNavigation(url, this.props.router)) {\n      e.preventDefault()\n\n      if (url === history.location.pathname + history.location.search) {\n        // return immediately if the url isn't changing.  Pushing the existing URL onto state will override the \n        // current state and going forward then back will yield a broken page.\n        return\n      }\n\n      if (this.props.history) {\n        this.props.history.push(url, state && state.toJSON ? state.toJSON() : state)\n      } else {\n        // Fallback to redirect\n        window.location.href = url\n      }\n    }\n  }\n\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\n/**\n * Returns an object containing the values from props corresponding to keys that start with \"data-\"\n * @param {Object} props\n * @return {Object}\n */\nexport default function dataProps(props) {\n  const result = {}\n\n  for (let name in props) {\n    if (name.startsWith('data-')) {\n      result[name] = props[name]\n    }\n  }\n\n  return result\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport { createMuiTheme } from '@material-ui/core/styles'\nimport merge from 'lodash/merge'\n\nexport default function createTheme(values = {}) {\n  let config = {}\n\n  merge(config, {\n    typography: {\n      useNextVariants: true,\n    },\n\n    palette: {\n      // primary\n      // secondary\n    },\n    \n    margins: {\n      // vertical margin on Container component\n      container: 15,\n\n      // horizontal margin on Row component\n      row: 15\n    },\n\n    zIndex: {\n      amp: {\n        // the z-index for modals in amp\n        modal: 2147483646\n      }\n    },\n\n    // The height of the app header\n    headerHeight: 64,\n\n    // Override the icon for all expanders in collapsed state - this should be a React component class, for example @material-ui/icons/Add\n    ExpandIcon: null,\n\n    // Override the icon for all expanders in expanded state - this should be a React component classm for example @material-ui/icons/Remove\n    CollapseIcon: null\n  }, values)\n\n  const theme = createMuiTheme(config)\n\n  if (!theme.maxWidth) {\n    theme.maxWidth = `${theme.breakpoints.values.lg}px`\n  }\n\n  return theme\n}","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component, Fragment } from 'react'\nimport { observer, inject } from 'mobx-react'\nimport ActionButton from './ActionButton'\nimport Filter from './Filter'\nimport PropTypes from 'prop-types'\nimport Drawer from './Drawer'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport classnames from 'classnames'\nimport grey from '@material-ui/core/colors/grey'\nimport { Hbox } from './Box'\n\nexport const styles = theme => ({\n  clear: {\n    ...theme.typography.caption,\n    padding: 0,\n    marginLeft: '10px',\n    textDecoration: 'underline'\n  },\n  clearDisabled: {\n    color: grey[400]\n  },\n  drawer: {\n    height: '75vh'\n  }\n})\n\n/**\n * A button that when clicked, opens a drawer containing the `Filter` view. Current filters\n * are displayed in the button text.\n */\n@withStyles(styles, { name: 'RSFFilterButton' })\n@inject('app')\n@observer\nexport default class FilterButton extends Component {\n\n  static propTypes = {\n    /**\n     * An instance of `SearchResultModelBase`\n     */\n    model: PropTypes.object,\n\n    /**\n     * CSS classes\n     */\n    classes: PropTypes.object,\n\n    /**\n     * Props for the underlying `Filter` component\n     */\n    drawerProps: PropTypes.object,\n\n    /**\n     * The label for the button and the drawer header.  Defaults to \"Filter\".\n     */\n    title: PropTypes.string,\n\n    /**\n     * Set to true to hide the clear link that is shown by default when one or more filters \n     * is selected.  Defaults to false.\n     */\n    hideClearLink: PropTypes.bool,\n\n    /**\n     * Text for the clear link.  Defaults to \"clear all\".\n     */\n    clearLinkText: PropTypes.string\n  }\n\n  static defaultProps = {\n    title: 'Filter',\n    drawerProps: {},\n    hideClearLink: false,\n    clearLinkText: \"clear all\"\n  }\n\n  constructor({ app }) {\n    super()\n\n    const openFilter = app.location.search.indexOf('openFilter') !== -1\n\n    this.state = {\n      open: openFilter, \n      mountDrawer: openFilter\n    }\n  }\n\n  render() {\n    const { classes, app, model, title, drawerProps, hideClearLink, clearLinkText, ...props } = this.props\n    const { open, mountDrawer } = this.state\n    const { clear, clearDisabled, drawer, ...buttonClasses } = classes\n    const pwaPath = app.location.pathname.replace(/\\.amp/, '')\n    const pwaSearch = app.location.search || ''\n    const queryChar = pwaSearch ? '&' : '?'\n    const ampUrl = pwaPath + pwaSearch + queryChar + 'openFilter'\n\n    return (\n      <Fragment>\n        <ActionButton \n          label={title}\n          href={ app.amp ? ampUrl : null }\n          value={this.getFilterList()} \n          classes={buttonClasses}\n          {...props} \n          onClick={this.onClick}\n        />\n        {!app.amp && (\n          <Drawer \n            ModalProps={{\n              keepMounted: true\n            }}\n            classes={{ paper: classes.drawer }}\n            anchor=\"bottom\"\n            title={\n              <Hbox justifyContent=\"center\">\n                <div>{title}</div>\n                { hideClearLink || model.filters.length === 0 ? null : (\n                  <button \n                    className={classnames({\n                      [clear]: true,\n                      [clearDisabled]: model.loading\n                    })} \n                    onClick={() => !model.loading && model.clearAllFilters()}\n                  >\n                    {clearLinkText}\n                  </button>\n                )}\n              </Hbox>\n            } \n            open={open} \n            onRequestClose={this.toggleOpen.bind(this, false)} \n          >\n            {mountDrawer && (\n              <Filter model={model} onViewResultsClick={this.onViewResultsClick} {...drawerProps}/>\n            )}\n          </Drawer>      \n        )}\n      </Fragment>\n    )\n  }\n\n  onClick = (e) => {\n    if (this.props.onClick) {\n      this.props.onClick(e)\n    }\n\n    if (!e.defaultPrevented) {\n      this.toggleOpen(true) \n    }\n  }\n\n  toggleOpen = (open) => {\n    this.setState({ open })\n\n    if (open) {\n      this.setState({ mountDrawer: true, open: true })\n    } else {\n      this.setState({ open: false })\n    }\n  }\n\n  onViewResultsClick = () => {\n    this.toggleOpen(false)\n  }\n\n  getFilterList = () => {\n    const { filters, facetGroups } = this.props.model\n\n    if (!filters || !facetGroups) return null\n    if (filters.length > 1) return `${filters.length} selected` \n\n    const names = []\n    const selection = {}\n\n    for (let facet of filters) {\n      selection[facet] = true\n    }\n    \n    for (let group of facetGroups) {\n      for (let facet of group.facets) {\n        if (selection[facet.code]) {\n          names.push(facet.name)\n        }\n      }\n    }\n\n    return names.length ? names.join(', ') : null    \n  }\n\n}\n\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport SwipeableViews from 'react-swipeable-views'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport ChevronLeft from '@material-ui/icons/ChevronLeft'\nimport ChevronRight from '@material-ui/icons/ChevronRight'\nimport IconButton from '@material-ui/core/IconButton'\nimport Portal from '@material-ui/core/Portal'\nimport { fade } from '@material-ui/core/styles/colorManipulator'\nimport classnames from 'classnames'\nimport { ReactPinchZoomPan } from 'react-pinch-zoom-pan'\nimport TabsRow from './TabsRow'\nimport analytics from './analytics'\nimport { inject, observer } from 'mobx-react'\nimport AmpImageSwitcher from './amp/AmpImageSwitcher'\nimport LoadMask from './LoadMask'\nimport Image from './Image'\n\nconst paletteIconTextColor = '#77726D'\n\nconst imagePropType = PropTypes.shape({\n  src: PropTypes.string.isRequired,\n  alt: PropTypes.string\n})\n\nexport const styles = theme => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column',\n    position: 'relative',\n\n    '& img': {\n      display: 'block'\n    }\n  },\n\n  swipeWrap: {\n    position: 'relative',\n    overflow: 'hidden',\n    flex: 1,\n    '& .react-swipeable-view-container, & > div:first-child': {\n      height: '100%'\n    }\n  },\n\n  imageWrap: {\n    height: '100%',\n    width: '100%',\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'stretch',\n    '& img': {\n      maxHeight: '100%',\n      maxWidth: '100%',\n      objectFit: 'contain'\n    }\n  },\n\n  thumbsTitle: {\n    textTransform: 'uppercase',\n  },\n\n  productThumb: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  },\n\n  thumbs: {\n    marginTop: `${theme.margins.container}px`\n  },\n\n  thumbnail: {\n    paddingBottom: '8px',\n    margin: '0 2px',\n    boxSizing: 'content-box',\n    height: '50px',\n    width: '50px'\n  },\n\n  activeThumbs: {\n    position: 'absolute',\n    width: '100%',\n    bottom: '20px'\n  },\n\n  selected: {\n    borderColor: '#D0D0D0'\n  },\n\n  arrows: {\n    [theme.breakpoints.down('xs')]: {\n      display: 'none'\n    }\n  },\n\n  arrow: {\n    position: 'absolute',\n    top: '50%',\n    marginTop: '-24px'\n  },\n\n  leftArrow: {\n    left: 0,\n  },\n\n  rightArrow: {\n    right: 0,\n  },\n\n  icon: {\n    height: '30px',\n    width: '30px'\n  },\n\n  dot: {\n    backgroundColor: fade(theme.palette.text.primary, 0.25),\n    width: 8,\n    height: 8,\n    borderWidth: '1px',\n    borderStyle: 'solid',\n    borderColor: theme.palette.background.paper,\n    borderRadius: '50%',\n    display: 'inline-block',\n    margin: '0 2px',\n    // Same duration as SwipeableViews animation\n    transitionDuration: '0.35s'\n  },\n\n  dotSelected: {\n    backgroundColor: theme.palette.text.primary\n  },\n\n  dots: {\n    position: 'absolute',\n    bottom: '5px',\n    textAlign: 'center',\n    width: '100%'\n  },\n\n  viewerToggle: {\n    transform: 'scale(0.4)',\n    position: 'absolute',\n    top: 0,\n    right: 0,\n    background: fade(theme.palette.text.icon || paletteIconTextColor, 0.4),\n    borderRadius: '50%',\n    width: '100px',\n    height: '100px',\n    transitionDuration: '0.5s',\n    '-webkit-tap-highlight-color': 'rgba(0, 0, 0, 0)'\n  },\n\n  viewerActive: {\n    transform: 'scale(0.4) rotateZ(45deg)'\n  },\n\n  viewerOverlay: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    background: theme.palette.background.paper,\n    zIndex: 9999,\n    transitionDuration: '0.5s',\n    transform: 'translateY(100%)',\n    visibility: 'hidden', // prevents lightbox from showing near the bottom of screen when browser controls hide on ios\n    '& img': {\n      margin: 'auto',\n      maxHeight: '100%',\n      maxWidth: '100%'\n    },\n    // Hack to fix root div height of pan/zoom/pinch container\n    '& > div:first-child': {\n      height: '100%',\n    }\n  },\n\n  viewerOverlayActive: {\n    transform: 'translateY(0%)',\n    visibility: 'visible'\n  },\n\n  tabsRowRoot: {\n    boxShadow: 'none',\n  },\n\n  tabScroller: {\n    [theme.breakpoints.down('xs')]: {\n      padding: `0 ${theme.margins.container}px`\n    }\n  },\n\n  indicator: {\n    display: 'none'\n  },\n\n  mask: {\n    opacity: '0.8'\n  }\n\n})\n\n/** \n * A swipeable image selector suitable for PDPs\n */\n@withStyles(styles, { name: 'RSFImageSwitcher' })\n@inject('app')\n@observer\nexport default class ImageSwitcher extends Component {\n\n  static propTypes = {\n\n    /**\n     * If specified, then the image_switched analytics event will be\n     * fired when an image is selected and the product's images and thumbnails will\n     * automatically be displayed.\n     */\n    product: PropTypes.object,\n\n    /**\n     * An array of (URL or image object) for the full size images\n     */\n    images: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, imagePropType])).isRequired,\n\n    /**\n     * An array of thumbnails to display below the main image.  You can also\n     * specify `false` to hide the thumbnails entirely.\n     */\n    thumbnails: PropTypes.oneOfType([PropTypes.bool, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, imagePropType]))]),\n\n    /**\n     * Display left/right arrows for navigating through images\n     */\n    arrows: PropTypes.bool,\n\n    /**\n     * Display indicator dots at the bottom of the component\n     */\n    indicators: PropTypes.bool,\n\n    /**\n     * Optional title for thumbnails block\n     */\n    thumbnailsTitle: PropTypes.string,\n\n    /*\n     * Option to show thumbnails only when zoomed view is active\n     */\n    viewerThumbnailsOnly: PropTypes.bool,\n\n    /**\n     * Props to apply to the Image component used to display the product thumbnail while\n     * the product data is loading\n     */\n    loadingThumbnailProps: PropTypes.object,\n\n    /*\n     * Option to manually set the selected index\n     */\n    selectedIndex: PropTypes.number,\n\n    /**\n     * The URL of image to load if an image fails to load\n     */\n    notFoundSrc: PropTypes.string,\n\n    /**\n     * Config options for the image viewer\n     */\n    reactPinchZoomPanOptions: PropTypes.shape({\n      onPinchStart: PropTypes.func,\n      onPinchStop: PropTypes.func,\n      initialScale: PropTypes.number,\n      maxScale: PropTypes.number\n    })\n  }\n\n  static defaultProps = {\n    images: [],\n    thumbnails: [],\n    viewerThumbnailsOnly: false,\n    arrows: true,\n    indicators: false,\n    loadingThumbnailProps: {},\n    reactPinchZoomPanOptions: {\n      maxScale: 3\n    }\n  }\n\n  state = {\n    selectedIndex: 0,\n    viewerActive: false\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    if (typeof nextProps.selectedIndex === 'number' && nextProps.selectedIndex !== prevState.selectedIndex) {\n      return { selectedIndex: nextProps.selectedIndex }\n    }\n    return null\n  }\n\n  renderViewerToggle(withClose) {\n    return (\n      <div\n        onClick={() => this.toggleViewer()}\n        className={classnames(this.props.classes.viewerToggle, { [this.props.classes.viewerActive]: this.state.viewerActive })}\n      >\n        <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\">\n          <line x1=\"50\" y1=\"25\" x2=\"50\" y2=\"75\" strokeWidth=\"4\" stroke=\"white\" />\n          <line x1=\"25\" y1=\"50\" x2=\"75\" y2=\"50\" strokeWidth=\"4\" stroke=\"white\" />\n        </svg>\n      </div>\n    );\n  }\n\n  toggleViewer() {\n    if (this.state.viewerActive) {\n      document.body.classList.remove('moov-modal')\n    } else {\n      document.body.classList.add('moov-modal')\n    }\n    \n    this.setState({ viewerActive: !this.state.viewerActive });\n  }\n\n  renderDot(index) {\n    const classes = classnames(\n      this.props.classes.dot,\n      { [this.props.classes.dotSelected]: index === this.state.selectedIndex }\n    );\n    return <div key={index} className={classes} />\n  }\n\n  get thumbnails() {\n    const { thumbnails, product } = this.props\n    if (thumbnails === false) return []\n    const _thumbnails = thumbnails && thumbnails.length ? thumbnails : product && product.thumbnails || []\n    return _thumbnails.map(e => {\n      return typeof e === 'string' ? { src: e, alt: 'thumbnail' } : e\n    })\n  }\n\n  get images() {\n    const { images, product } = this.props\n    const _images = images && images.length ? images : product && product.images || []\n    return _images.map(e => {\n      return typeof e === 'string' ? { src: e, alt: 'product' } : e\n    })\n  }\n\n  renderThumbnails() {\n    const { classes, thumbnailsTitle, notFoundSrc } = this.props\n    const { thumbnails } = this\n    const modifiedThumbs = thumbnails && thumbnails.map(({ src, alt }) => ({ imageUrl: src, alt }))\n    const { viewerActive, selectedIndex } = this.state\n\n    return thumbnails && thumbnails.length > 0 && (\n      <div className={classnames(classes.thumbs, { [classes.activeThumbs]: viewerActive })}>\n        <div className=\"field\">\n          <label className={classes.thumbsTitle}>{thumbnailsTitle}</label>\n        </div>\n        <TabsRow\n          classes={{\n            scroller: classes.tabScroller,\n            root: classes.tabsRowRoot\n          }}\n          imageProps={{\n            className: classes.thumbnail,\n            notFoundSrc,\n            fill: true\n          }}\n          centered\n          initialSelectedIdx={selectedIndex}\n          onTabChange={(e, selectedIndex) => this.setState({ selectedIndex })}\n          items={modifiedThumbs}\n        />\n      </div>\n    )\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState && \n        prevState.selectedIndex && \n        prevState.selectedIndex !== this.state.selectedIndex && \n        this.props.product) {\n      analytics.fire('imageSwitched', { product: this.props.product, imageUrl: this.props.images[this.state.selectedIndex] })\n    }\n  }\n\n  render() {\n    let { app, product, classes, className, arrows, indicators, style, reactPinchZoomPanOptions, loadingThumbnailProps, viewerThumbnailsOnly, notFoundSrc } = this.props\n    const { images, thumbnails } = this\n\n    if (app.amp) return (\n      <AmpImageSwitcher \n        images={images}\n        thumbnails={thumbnails} \n        className={className} \n        classes={{ root: classes.root, dot: classes.dot, dots: classes.dots, dotSelected: classes.dotSelected, thumbnails: classes.thumbs }}\n        arrows={arrows}\n        indicators={indicators}\n        thumbnails={viewerThumbnailsOnly ? null : this.thumbnails}\n      />\n    )\n\n    const { selectedIndex, viewerActive } = this.state\n    const selectedImage = images[selectedIndex]\n\n    return (\n      <div className={classnames(className, classes.root)} style={style}>\n        {/* Full Size Images */}\n        <div className={classes.swipeWrap}>\n          <SwipeableViews index={selectedIndex} onChangeIndex={i => this.setState({ selectedIndex: i })}>\n            {images.map(({ src, alt }, i) => (\n              <div key={i} className={classes.imageWrap}>\n                { app.amp ? (\n                  <amp-img \n                    src={src} \n                    alt=\"product\" \n                    layout=\"fill\"\n                  />\n                ) : (\n                  <Image\n                    key={src} \n                    notFoundSrc={notFoundSrc} \n                    src={i===0 && app.loading ? null : src} // need to clear src when app.loading is true so that the onLoad event will fire and the loading thumbnail will be removed\n                    alt={alt || \"product\"} \n                    onLoad={i === 0 ? this.clearLoadingProduct : null} \n                  /> \n                )}\n              </div>\n            ))}\n          </SwipeableViews>\n\n          {arrows && (\n            <div className={classes.arrows}>\n              {selectedIndex !== 0 && (\n                <IconButton className={classnames(classes.arrow, classes.leftArrow)} onClick={() => this.setState({ selectedIndex: selectedIndex - 1 })}>\n                  <ChevronLeft classes={{ root: classes.icon }} />\n                </IconButton>\n              )}\n              {selectedIndex !== images.length - 1 && (\n                <IconButton className={classnames(classes.arrow, classes.rightArrow)} onClick={() => this.setState({ selectedIndex: selectedIndex + 1 })}>\n                  <ChevronRight classes={{ root: classes.icon }} />\n                </IconButton>\n              )}\n            </div>\n          )}\n\n          {indicators && (\n            <div className={classes.dots}>\n              {images.map((_, index) => this.renderDot(index))}\n            </div>\n          )}\n\n          {product && (\n            <LoadMask show={product.loadingImages} className={classes.mask}/>\n          )}\n\n          {product && app.loadingProduct && app.loadingProduct.thumbnail && (\n            <Image src={app.loadingProduct.thumbnail} className={classes.productThumb} {...loadingThumbnailProps} fill/>\n          )}\n\n          <Portal>\n            <div className={classnames(classes.viewerOverlay, { [classes.viewerOverlayActive]: viewerActive })}>\n              <ReactPinchZoomPan {...reactPinchZoomPanOptions} render={obj => {\n                return (\n                  <div style={{\n                    overflow: 'hidden',\n                    position: 'relative',\n                    height: '100%'\n                  }}>\n                    <div style={{\n                      display: 'flex',\n                      height: '100%'\n                    }}>\n                      { selectedImage && (\n                        <img\n                          src={selectedImage.src}\n                          alt={selectedImage.alt}\n                          style={{\n                            width: '100%',\n                            height: 'auto',\n                            transform: `scale(${obj.scale}) translateY(${obj.y}px) translateX(${obj.x}px)`\n                          }} \n                        />\n                      )}\n                    </div>\n                  </div>\n                )\n              }} />\n              {viewerActive && this.renderViewerToggle()}\n              {viewerActive && this.renderThumbnails()}\n            </div>\n          </Portal>\n          {!viewerActive && this.renderViewerToggle()}\n        </div>\n\n        {!viewerActive && !viewerThumbnailsOnly && this.renderThumbnails()}\n      </div>\n    )\n\n  }\n\n  clearLoadingProduct = () => {\n    this.props.app.applyState({ loadingProduct: null })\n  }\n\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport { types } from \"mobx-state-tree\"\nimport React, { Component, Fragment } from 'react'\nimport { observer, inject } from \"mobx-react\"\nimport PropTypes from 'prop-types'\nimport Drawer from '@material-ui/core/Drawer'\nimport ListItemText from '@material-ui/core/ListItemText'\nimport MenuList from '@material-ui/core/MenuList'\nimport MenuItem from '@material-ui/core/MenuItem'\nimport ChevronLeft from '@material-ui/icons/ChevronLeft'\nimport ChevronRight from '@material-ui/icons/ChevronRight'\nimport ListItemIcon from '@material-ui/core/ListItemIcon'\nimport withStyles from '@material-ui/core/styles/withStyles'\nimport ExpandLess from '@material-ui/icons/ExpandLess'\nimport ExpandMore from '@material-ui/icons/ExpandMore'\nimport Collapse from '@material-ui/core/Collapse'\nimport Link from './Link' \nimport classnames from 'classnames'\nimport AmpMenu from './amp/AmpMenu'\nimport withTheme from '@material-ui/core/styles/withTheme'\n\nexport const MenuItemModel = types\n  .model(\"MenuItemModel\", {\n    text: types.optional(types.string, ''),\n    url: types.maybeNull(types.string),\n    state: types.frozen(),\n    className: types.maybeNull(types.string),\n    image: types.maybeNull(types.string),\n    items: types.maybeNull(types.array(types.late(() => MenuItemModel))),\n    root: types.optional(types.boolean, false),\n    server: types.optional(types.boolean, false),\n    prefetch: types.maybeNull(types.string),\n    expanded: false\n  })\n  .actions(self => ({\n    toggle() {\n      self.expanded = !self.expanded\n    },\n    collapse() {\n      self.expanded = false\n    }\n  }))\n\nexport const MenuModel = types\n  .model(\"MenuModel\", {\n    open: false,\n    levels: types.optional(types.array(MenuItemModel), []),\n    level: types.optional(types.number, 0)\n  })\n  .actions(self => ({\n\n    /**\n     * Closes the menu\n     */\n    close() {\n      self.open = false\n    },\n\n    /**\n     * Toggles the open state of the menu\n     */\n    toggle() {\n      self.open = !self.open\n    },\n\n    /**\n     * Updates the root node\n     * @param {Object} root \n     */\n    setRoot(root) {\n      self.levels[0] = MenuItemModel.create(root)\n    },\n\n    /**\n     * Selects an item in the menu\n     * @param {MenuItem} item\n     * @param {Object} options\n     */\n    setSelected(item, options = {}) {\n      item = MenuItemModel.create(item.toJSON())\n      \n      self.level++\n      if (self.levels.length <= self.level) {\n        self.levels.push(item)\n      } else {\n        self.levels[self.level] = item\n      }\n\n      if (options.expandFirstItem && item.items.every(itm => itm.expanded === false)) {\n        item.items[0].expanded = true\n      }\n    },\n\n    /**\n     * Goes back one level\n     */\n    goBack() {\n      self.level = Math.max(0, self.level - 1)\n      self.collapseAll()\n    },\n\n    /**\n     * Closes all expandable sections\n     */\n    collapseAll() {\n      setTimeout(() => {\n        for (let level of self.levels) {\n          for (let item of level.items) {\n            item.collapse()\n          }\n        }\n      }, 200)\n    }\n\n  }))\n\nexport const styles = (theme) => ({\n  drawer: {\n    zIndex: theme.zIndex.modal + 20,\n    display: 'flex',\n    flexDirection: 'column',\n    borderTop: `${theme.headerHeight}px solid transparent`,\n    'body.moov-safari &': {\n      // Turning off momentum scrolling on iOS here to fix frozen body issue\n      // Source: https://moovweb.atlassian.net/browse/PRPL-342\n      '-webkit-overflow-scrolling': 'auto'\n    }\n  },\n\n  list: {\n    flex: 'none', \n    overflowY: 'auto',\n    overflowX: 'hidden',\n    maxHeight: '100%',\n    padding: 0\n  },\n\n  listPadding: {\n    padding: 0\n  },\n\n  header: {\n    position: 'absolute',\n    left: '10px',\n    top: '12px'\n  },\n\n  icon: {\n    marginRight: '0'\n  },\n\n  headerText: {\n    textAlign: 'center',\n    fontWeight: '600',\n    textTransform: 'uppercase',\n    fontSize: theme.typography.body1.fontSize\n  },\n\n  hbox: {\n    display: 'flex',\n    flexDirection: 'row',\n    transition: 'all ease-out .2s'\n  },\n\n  listItem: {\n    textTransform: 'uppercase',\n    lineHeight: 'initial',\n    fontSize: theme.typography.body1.fontSize\n  },\n\n  link: {\n    textDecoration: 'none',\n    color: 'inherit'\n  },\n\n  listItemImage: {\n    width: '40px',\n    height: '40px',\n    marginRight: 0\n  },\n\n  listItemIcon: {\n    marginRight: 0\n  },\n\n  expander: {\n    backgroundColor: `${theme.palette.primary.paper} !important`,\n  },\n\n  leaf: {\n    textTransform: 'none',\n    ...theme.typography.body1\n  },\n\n  expanded: {\n    backgroundColor: `${theme.palette.secondary.main} !important`,\n    color: theme.palette.secondary.contrastText,\n    '& svg': {\n      color: theme.palette.secondary.contrastText\n    }\n  },\n\n  drawerFixed: {\n    top: 0,\n    height: '100vh',\n    borderTop: 'none'\n  },\n\n  modal: {}\n})\n\n/**\n * The main app menu that slides in from the left when the AppHeader's menu button is clicked.\n * Children are rendered above the list of menu items.\n * \n * In addition to the CSS classes that can be overridden of menu subcomponents, you can also\n * assign specific classes to individual menu items by specifying a value for the `className`\n * field on any instance of `MenuItemModel`.\n */\n@withTheme()\n@withStyles(styles, { name: 'RSFMenu' })\n@inject('app')\n@observer\nexport default class Menu extends Component {\n\n  static propTypes = {\n    menu: PropTypes.object,\n\n    /**\n     * The width of the drawer in pixels\n     */\n    drawerWidth: PropTypes.number,\n\n    /**\n     * An element to display at the top of the root of the menu\n     */\n    rootHeader: PropTypes.element,\n\n    /**\n     * An element to display at the bottom of the root of the menu\n     */\n    rootFooter: PropTypes.element,\n\n    /**\n     * Set to true to use expandable menu items below depth 1\n     */\n    useExpanders: PropTypes.bool,\n\n    /**\n     * Set to true to expand first item for not root items\n     */\n    expandFirstItem: PropTypes.bool,\n\n    /**\n     * Set to true to display the menu\n     */\n    open: PropTypes.bool,\n\n    /**\n     * Set to true to dock the menu so that it's always open and not modal\n     */\n    persistent: PropTypes.bool,\n\n    /**\n     * CSS classes for this component\n     */\n    classes: PropTypes.objectOf(PropTypes.string),\n\n    /**\n     * Called when the menu is closed\n     */\n    onClose: PropTypes.func,\n\n    /**\n     * Set to true to render a simple set of expanders rather than a multi-level drill down.\n     * Defaults to false.\n     */\n    simple: PropTypes.bool,\n\n    /**\n     * The icon to use for collapsed groups\n     */\n    ExpandIcon: PropTypes.func,\n\n    /**\n     * The icon to use for expanded groups\n     */\n    CollapseIcon: PropTypes.func,\n\n    /**\n     * Sets the side of the screen from which the menu appears.\n     */\n    align: PropTypes.oneOf(['left', 'right']),\n\n    /**\n     * A function to render the contents of a menu item.  It is passed the following arguments:\n     * \n     * 1.) item - the MenuItemModel instance. \n     * 2.) leaf - `true` when the item is a leaf node, otherwise `false`\n     * \n     * Return undefined to render the default contents\n     * \n     * Example:\n     * \n     *  itemRenderer={(item, leaf) => {\n     *    return leaf ? <ListItemText primary={item.text}/> : undefined\n     *  }}\n     */\n    itemRenderer: PropTypes.func\n  }\n\n  static defaultProps = {\n    drawerWidth: 330,\n    simple: false,\n    expandFirstItem: false,\n    align: 'left'\n  }\n\n  render() {\n    const { app, classes, className, align, rootHeader, rootFooter, drawerWidth, simple, persistent, children } = this.props\n    const { amp, menu } = app\n    const { levels, level } = menu\n    const position = -drawerWidth * level;\n\n    if (!menu) {\n      return null\n    } else if (amp) {\n      return <AmpMenu {...this.props}/>\n    }\n\n    return (\n      <Drawer \n        variant={persistent ? 'persistent' : 'temporary' } \n        open={menu.open || persistent} \n        onClose={menu.close} \n        anchor={align}\n        ModalProps={{\n          keepMounted: true\n        }}\n        PaperProps={{\n          style: { width: `${drawerWidth}px` }\n        }}\n        classes={{ \n          root: className,\n          paper: classnames(classes.drawer, { \n            [classes.drawerFixed]: persistent, \n          }),\n          modal: classes.modal \n        }}\n      >\n        { children }\n        { simple ? this.renderSimple() : (\n          <div className={classes.hbox} style={{ transform: `translateX(${position}px)`, flex: 1 }}>\n            {levels.map((list, depth) => (\n              <MenuList style={{ width: `${drawerWidth}px` }} classes={{ root: classes.list, padding: classes.padding }} key={depth}>\n                {list.root && rootHeader}\n                {!list.root && (\n                  <MenuItem divider button onClick={this.goBack}>\n                    <ListItemIcon classes={{ root: classes.header }}>\n                      <ChevronLeft className={classes.icon} />\n                    </ListItemIcon>\n                    <ListItemText\n                      classes={{ root: classes.headerText }}\n                      primary={<div className={classes.headerText}>{list.text} </div>}\n                    />\n                  </MenuItem>\n                )}\n                {list.items && list.items.map((item, key) => this.renderItem(depth, item, key))}\n                {list.root && rootFooter}\n              </MenuList>\n            ))}\n          </div>\n        )}\n        { this.renderLinksForSEO() }\n      </Drawer> \n    )\n  }\n\n  /**\n   * @private\n   * Renders simple anchor tags for all links in a collapsed div so that\n   * search engine bots can crawl them.\n   */\n  renderLinksForSEO() {\n    const levels = this.props.app.menu.levels\n    const root = levels.length && levels[0]\n\n    if (!root) return null\n    \n    let links = [], key = 0\n\n    const findLinks = ({ items }) => {\n      for (let i=0; i<items.length; i++) {\n        const item = items[i]\n\n        if (item.url) {\n          links.push(<li key={key++}><Link to={item.url}>{item.text}</Link></li>)\n        }\n\n        if (item.items) {\n          findLinks(item)\n        }\n      }\n    }\n\n    findLinks(root)\n\n    return <noscript><ul>{links}</ul></noscript>\n  }\n\n  /**\n   * Renders the menu as a simple list of expandable sections\n   * @return {MenuList}\n   */\n  renderSimple() {\n    const { rootHeader, rootFooter, app: { menu }, classes } = this.props\n    const root = menu && menu.levels && menu.levels[0]\n\n    if (!root) return null\n\n    return (\n      <MenuList classes={{ padding: classes.list }}>\n        { rootHeader }\n        { root.items.map((item, i) => this.renderItem(1, item, i)) }\n        { rootFooter }\n      </MenuList>\n    )\n  }\n\n  /**\n   * Renders a menu item\n   * @param {Numbere} depth The depth of the item in the menu\n   * @param {MenuItem} item The menu item\n   * @param {String} key a key for the react element\n   * @return {React.Element}\n   */\n  renderItem(depth, item, key) {\n    if (item.items) {\n      return this.renderGroup(depth, item, key)\n    }\n    return this.renderLeaf(item, key)    \n  }\n\n  renderGroup(depth, item, key) {\n    let { app: { menu }, classes, useExpanders, simple } = this.props\n    const showExpander = simple || (depth > 0 && useExpanders)\n\n    const elements = [\n      <MenuItem\n        key={key}\n        button\n        divider\n        onClick={showExpander ? this.toggleItemExpaned.bind(this, item) : this.slideToItem.bind(this, item, menu)}\n        classes={{\n          root: classnames(classes.listItem, item.className, {\n            [classes.expanded]: item.expanded,\n            [classes.expander]: showExpander\n          })\n        }}\n      >\n        { this.renderItemContents(item, false, showExpander) }\n      </MenuItem>\n    ]\n\n    if (showExpander) {\n      elements.push(\n        <Collapse in={item.expanded} timeout=\"auto\" key={`${key}-collapse`}>\n          <MenuList component=\"div\" classes={{ root: classes.list }}>\n            {item.items && item.items.map(this.renderItem.bind(this, depth + 1))}\n          </MenuList>\n        </Collapse>\n      )\n    }\n\n    return elements\n  }\n\n  renderLeaf(item, key) {\n    const { classes, app: { location } } = this.props    \n\n    return (\n      <Link key={key} to={item.url} className={classes.link} server={item.server} state={item.state ? () => JSON.parse(item.state) : null}>\n        <MenuItem\n          button\n          divider\n          selected={location.pathname === item.url.replace(/\\?.*/, '')}\n          classes={{\n            root: classnames(classes.listItem, classes.leaf, item.className)\n          }}\n        >\n          { this.renderItemContents(item, true) }\n        </MenuItem>\n      </Link>\n    );\n  }\n\n  renderItemContents(item, leaf, showExpander) {\n    let { itemRenderer, classes, ExpandIcon, CollapseIcon, theme } = this.props\n\n    let contents\n    \n    if (itemRenderer) {\n      contents = itemRenderer(item, leaf)\n    } \n    \n    if (contents) {\n      return contents\n    } else if (leaf) {\n      return (\n        <Fragment>\n          {item.image && (\n            <ListItemIcon>\n              <img className={classes.listItemImage} alt={item.text} src={item.image} />\n            </ListItemIcon>\n          )}\n          <ListItemText\n            primary={item.text}\n            disableTypography\n          />\n        </Fragment>\n      )\n    } else {\n      ExpandIcon = ExpandIcon || theme.ExpandIcon || ExpandMore\n      CollapseIcon = CollapseIcon || theme.CollapseIcon || ExpandLess\n  \n      return (\n        <Fragment>\n          {item.image && (\n            <ListItemIcon>\n              <img className={classes.listItemImage} alt={item.text} src={item.image} />\n            </ListItemIcon>\n          )}\n          <ListItemText\n            primary={item.text}\n            disableTypography\n          />\n          <ListItemIcon className={classes.listItemIcon}>\n            {showExpander ? (\n              item.expanded ? <CollapseIcon className={classes.icon} /> : <ExpandIcon className={classes.icon} />\n            ) : (\n              <ChevronRight className={classes.icon} />\n            )}\n          </ListItemIcon>\n        </Fragment>\n      )\n    }\n  }\n\n  slideToItem = (item, menu) => {\n    const { expandFirstItem } = this.props\n    menu.setSelected(item, { expandFirstItem })\n  }\n\n  goBack = () => {\n    this.props.app.menu.goBack()\n  }\n\n  toggleItemExpaned = (item) => {\n    item.toggle()\n  }\n\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport React, { Component, Fragment } from 'react'\nimport withStyles from \"@material-ui/core/styles/withStyles\"\nimport classnames from 'classnames'\nimport ResponsiveTiles from './ResponsiveTiles'\nimport PropTypes from 'prop-types'\nimport withStyleProps from './withStyleProps'\nimport { observer, inject } from 'mobx-react'\nimport Image from './Image'\n\nexport const styles = theme => ({\n  row: {\n    display: 'flex',\n    flexDirection: 'row',\n    alignItems: 'stretch'\n  },\n\n  blankRow: {\n    height: `${theme.margins.row}px`\n  },\n  \n  space: {\n    backgroundColor: theme.palette.background.default,\n    width: theme.margins.container + 'px'\n  },\n\n  '@keyframes shimmer': {\n    from: { backgroundPosition: '0 0'},\n    to: { backgroundPosition: '100vw 0' }\n  },\n  \n  shimmer: {\n    backgroundColor: theme.palette.background.shade,\n    animationDuration: '1s',\n    animationFillMode: 'forwards',\n    animationIterationCount: 'infinite',\n    animationName: 'shimmer',\n    animationTimingFunction: 'linear',\n    background: `linear-gradient(to right, #eee 0%, #e6e6e6 20%, #eee 40%)`,\n  },\n\n  fullscreen: {\n    position: 'absolute',\n    left: 0,\n    right: 0,\n    bottom: 0,\n    top: theme.headerHeight\n  },\n\n  filledContent: {\n    backgroundColor: theme.palette.background.default,\n    display: 'flex',\n    alignItems: 'center'\n  }\n})\n\n/**\n * The root component for a skeleton view\n */\nexport const Skeleton = withStyles(styles)(\n  ({ classes, children, fullscreen=false }) => (\n    <div \n      className={\n        classnames({ \n          [classes.shimmer]: true, \n          [classes.fullscreen]: fullscreen \n        })\n      }\n    >\n      {children}\n    </div>\n  )\n)\n\n/**\n * A row of space and content\n */\nexport const Row = withStyles(styles)(\n  ({ wrap, className, classes, children, ...style }) => (\n    <div \n      className={classnames(classes.row, className)} \n      style={{ flexWrap: wrap && 'wrap', ...style }}\n    >\n      {children}\n    </div>\n  )\n)\n\n/**\n * White space between content\n */\nexport const Space = withStyles(styles)(\n  ({ classes, ...style }) => <div data-rel=\"space\" className={classes.space} style={style}/>\n)\n\n/**\n * A placeholder for content with a gray background that shimmers\n */\nexport const Content = withStyles(styles)(({ children, className, classes, ...style }) => {\n  if (children) {\n    return <div className={classnames(className, classes.filledContent)} style={{ ...style }}>{children}</div>\n  } else {\n    return <div className={className} style={{ ...style }}/>\n  }\n})\n\n/**\n * A blank row.  You provide the height\n */\nexport const BlankRow = withStyles(styles)(({ classes, ...others }) => (\n  <Row className={classes.blankRow} {...others}>\n    <Space flex={1} />\n  </Row>\n))\n\n/**\n * When using ResposiveTiles in your view, use this component to replace\n * it in the load mask.\n */\n@withStyleProps(({ theme, spacing }) => ({\n  root: {\n    borderStyle: 'solid',\n    borderColor: theme.palette.background.default,\n    margin: `0 -${spacing}px !important`\n  },\n  tile: {\n    borderStyle: 'solid',\n    borderColor: theme.palette.background.default,\n    borderWidth: `0 ${spacing/2}px`\n  }\n}), { name: 'RSFSkeletonTiles' })\nexport class Tiles extends Component {\n\n  static propTypes = {\n    /**\n     * Should be the same as the spacing set on the ResponsiveTiles element\n     * that you're replacing.\n     */\n    spacing: PropTypes.number\n  }\n\n  render() {\n    const { spacing, classes, className, children, ...others } = this.props\n    \n    return (\n      <ResponsiveTiles \n        spacing={0} \n        className={classnames(classes.root, className)} \n        {...others}\n      >\n        { React.Children.map(children, (child, i) => (\n          <div className={classes.tile} key={i}>\n            { child }\n          </div>\n        ))}\n      </ResponsiveTiles>\n    )\n  }\n\n}\n\nTiles.defaultProps = {\n  spacing: 15\n}\n\n@withStyles(theme => ({\n  root: {\n    display: 'flex',\n    flexDirection: 'column'\n  },\n  image: {\n    width: '100%',\n    flex: 1,\n  }\n}))\n@observer\nexport class ImageSwitcher extends Component {\n\n  static propTypes = {\n    product: PropTypes.object,\n    thumbnails: PropTypes.bool,\n    loadingThumbnailProps: PropTypes.object\n  }\n\n  static defaultProps = {\n    thumbnails: true,\n    loadingThumbnailProps: {}\n  }\n\n  render() {\n    const { classes, thumbnails, product, loadingThumbnailProps } = this.props\n\n    return (\n      <div className={classes.root}>\n        { product && product.thumbnail ? (\n          <Row>\n            <Content flex=\"1\">\n              <Image src={product.thumbnail} className={classes.image} {...loadingThumbnailProps} fill/>\n            </Content>      \n          </Row>\n        ) : (\n          <Row className={classes.image}/>\n        )}\n        { thumbnails ? (\n          <Fragment>\n            <BlankRow/>\n            <Row height=\"58px\">\n              <Space/>\n              <Content flex=\"1\"/>\n              <Space/>\n            </Row>\n          </Fragment>\n        ) : null}\n      </div>\n    )\n  }\n}\n","/**\n * @license\n * Copyright © 2017-2018 Moov Corporation.  All rights reserved.\n */\nimport fetch from 'fetch'\nimport debounce from 'lodash/debounce'\nimport { types } from 'mobx-state-tree'\nimport { fetchLatest, StaleResponseError } from '../fetchLatest'\n\n// Ensures that responses are returned in order and that the previous request is canceled when a new request is sent.\nconst fetchSearchResults = fetchLatest(fetch)\n\n/**\n * Represents an individual link within a group\n */\nexport const ResultsModel = types.model('ResultsModel', {\n  /**\n   * The link text\n   */\n  text: types.string,\n  /**\n   * The link's target url\n   */\n  url: types.string,\n  /**\n   * A url for a thumbnail image\n   */\n  thumbnail: types.maybeNull(types.string),\n  /**\n   * The thumbnail height\n   */\n  thumbnailHeight: 120,\n  /**\n   * The thumbnail width\n   */\n  thumbnailWidth: 120,\n})\n\n/**\n * Represents a group of links withing the search results\n */\nexport const ResultsGroupModel = types\n  .model('ResultsGroupModel', {\n    /**\n     * The caption to display at the top of the group\n     */\n    caption: types.string,\n    /**\n     * The list of links to display\n     */\n    results: types.optional(types.array(ResultsModel), []),\n  })\n  .views(self => ({\n    get thumbnails() {\n      return self.results.some(r => r.thumbnail != null)\n    },\n  }))\n\n/**\n * The base model for site-wide searches.\n */\nconst SearchModelBase = types\n  .model('SearchModelBase', {\n    /**\n     * The search phrase entered by the user\n     */\n    text: '',\n    /**\n     * The resulting groups\n     */\n    groups: types.optional(types.array(ResultsGroupModel), []),\n    /**\n     * True to show the loading spinner\n     */\n    loading: false,\n    /**\n     * True to show the search popup\n     */\n    show: false,\n    /**\n     * Minimum search text length for submission\n     */\n    minimumTextLength: 1,\n  })\n  .actions(self => ({\n    /**\n     * Set `true` to show the search popup, `false` to hide.\n     * @param {Boolean} show\n     */\n    toggle(show) {\n      self.show = show\n    },\n    /**\n     * Update the search text\n     * @param {String} text\n     */\n    setText(text) {\n      self.text = text\n      if (self.text.trim().length >= self.minimumTextLength) {\n        self.loading = true\n        self.submit(text)\n      } else {\n        self.loading = false\n      }\n    },\n    /**\n     * Set `true` to show the loading spinner, `false` to hide.\n     * @param {Boolean} state\n     */\n    setLoading(loading) {\n      self.loading = loading\n    },\n    /**\n     * Submit the search for the given keyword.  Fetched calls are automatically debounced and serialized so that\n     * results are received in order.\n     * @param {String} keyword\n     */\n    submit: debounce(async keyword => {\n      if (!keyword) {\n        return\n      }\n\n      try {\n        const state = await fetchSearchResults(\n          `/search/suggest.json?q=${encodeURIComponent(keyword)}`,\n        ).then(res => res.json())\n        self.setGroups(state.search.groups)\n        self.setLoading(false)\n      } catch (e) {\n        if (!StaleResponseError.is(e)) {\n          self.setLoading(false)\n          throw e\n        }\n      }\n    }, 500),\n    /**\n     * Set the groups to be displayed\n     * @param {ResultsGroupModel[]} groups\n     */\n    setGroups(groups) {\n      self.groups = groups\n    },\n  }))\n\nexport default SearchModelBase\n"],"mappings":"AAOA;;;;;ACEA;;;;;ACCA;;;;;ACEA;;;;;ACSA;;;;;ACJA;;;;;;;;;ACFA;;;;;ACDA;;;;;ACLA;;;;;ACFA;;;;;ACQA;;;;;ACSA;;;;;ACAA;;;;;ACXA;;;;;ACHA","sourceRoot":""}