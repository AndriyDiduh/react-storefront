const data = {"menu":{"analytics":{"name":"analytics","items":[{"name":"configureAnalytics"}]},"environment":{"name":"environment","items":[{"name":"isServer"},{"name":"isClient"}]},"fetch":{"name":"fetch","items":[{"name":"fetchWithCookies"},{"name":"default"}]},"fetchLatest":{"name":"fetchLatest","items":[{"name":"default"},{"name":"StaleResponseError"}]},"format":{"name":"format","items":[{"name":"price"}]},"launchClient":{"name":"launchClient","items":[{"name":"default"}]},"persist":{"name":"persist","items":[{"name":"default"}]},"renderers":{"name":"renderers","items":[{"name":"getJS"},{"name":"renderHtml"},{"name":"renderInitialStateScript"},{"name":"renderScript"},{"name":"getScripts"},{"name":"renderPrefetchHeader"},{"name":"renderStyle"},{"name":"render"},{"name":"hydrate"}]},"withStyleProps":{"name":"withStyleProps","items":[{"name":"default"}]},"model":{"children":[{"name":"AppModelBase","items":[{"name":"BreadcrumbModel"}]},{"name":"CartModelBase","items":[{"name":"default"}]},{"name":"SearchModelBase","items":[{"name":"ResultsModel"},{"name":"ResultsGroupModel"},{"name":"default"}]},{"name":"SearchResultsModelBase","items":[{"name":"FacetModelBase"},{"name":"FacetGroupModelBase"},{"name":"SortBase"}]}]},"router":{"children":[{"name":"Router","items":[]},{"name":"cache","items":[{"name":"default"}]},{"name":"fromClient","items":[{"name":"default"}]},{"name":"fromServer","items":[{"name":"fetch"},{"name":"default"}]},{"name":"headers","items":[{"name":"SURROGATE_KEY"},{"name":"HANDLER"},{"name":"RESPONSE_TYPE"},{"name":"API_VERSION"},{"name":"REACT_STOREFRONT"},{"name":"XDN_VERSION"},{"name":"ROUTES"}]},{"name":"proxyUpstream","items":[{"name":"default"}]},{"name":"serviceWorker","items":[{"name":"cache"},{"name":"prefetchJsonFor"},{"name":"prefetch"},{"name":"abortPrefetches"},{"name":"resumePrefetches"},{"name":"configureCache"},{"name":"waitForServiceWorkerController"},{"name":"removeOldCaches"}]},{"name":"withGlobalState","items":[{"name":"default"}]}]},"utils":{"children":[{"name":"browser","items":[{"name":"isSafari"}]},{"name":"createGenerateClassName","items":[{"name":"default"}]},{"name":"dataProps","items":[{"name":"default"}]},{"name":"scriptInjector","items":[{"name":"injectScriptInHead"},{"name":"injectCodeInHead"},{"name":"removeScriptInHead"},{"name":"removeCodeInHead"}]},{"name":"state","items":[{"name":"lazyState"},{"name":"parseState"}]},{"name":"url","items":[{"name":"relativeURL"},{"name":"absoluteURL"},{"name":"canUseClientSideNavigation"}]}]}},"exports":{"analytics/configureAnalytics":{"name":"configureAnalytics","type":"function","async":false,"generator":false,"comments":"Configures the PWA to broadcast events to all specified targets.  Once configured, You can call any method on\non all targets by calling analytics.fire(method, ...params).\n\nExample:\n\n // src/analytics.js\n\n import { configureAnalytics } from 'react-storefront/analytics'\n import GoogleTagManagerTarget from 'react-storefront-analytics/GoogleTagManagerTarget'\n import MerkleSearchTarget from 'react-storefront-analytics/MerkleSearchTarget'\n\n configureAnalytics(\n   new GoogleTagManagerTarget({ apiKey: 'my_gtm_api_key' }),\n   new MerkleSearchTarget({ apiKey: 'my_merkle_api_key' })\n )\n\n// then, to broadcast an analytics event to all targets:\n\nimport analytics from 'react-storefront/analytics'\n\nanalytics.fire('someEvent', { foo: 'bar' }) // this will call the 'someEvent(data)' method on all configured targets and pass { foo: 'bar' } as the data argument.","params":[{"name":"targets","type":"Array","text":"An array of targets to notify when analytics events occur"}],"returns":[{"type":"AnalyticsProvider","text":""}]},"environment/isServer":{"name":"isServer","type":"function","async":false,"generator":false,"comments":"Returns true only when called on the server.","params":[],"returns":[{"type":"Boolean","text":""}]},"environment/isClient":{"name":"isClient","type":"function","async":false,"generator":false,"comments":"Returns true only when called on the client.","params":[],"returns":[{"type":"Boolean","text":""}]},"fetch/fetchWithCookies":{"name":"fetchWithCookies","type":"function","async":false,"generator":false,"comments":"The same as fetch, but automatically relays the cookies passed in from the browser to the upstream API.","params":[{"name":"url","type":"String","text":"The url to fetch"},{"name":"options","default":"{}","type":"Object","text":"Options for fetch"},{"name":"qsOptions","type":"String","text":"Options for serializing the request body using the qs package"}],"returns":[{"type":"Promise","text":""}]},"fetch/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"An implementation of the standard fetch API.  See https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API for options\n\nThis function is commonly used to fetch json data:\n\n const data = await fetch('https://jsonplaceholder.typicode.com/todos/1')\n   .then(res => res.json())\n\n... or string data:\n\n const text = await fetch('https://jsonplaceholder.typicode.com/todos/1')\n   .then(res => res.text())\n\n... but you can also use it to fetch binary data:\n\n const buffer = await fetch('https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf')\n   .then(res => res.arrayBuffer())\n\nIn addition to the standard fetch options, you can also specify:\n\n maxRedirects - number - The maximum number of redirects that fetch will follow before returning an error.  Defaults to 20.\n acceptInvalidCerts - boolean - Set to true to allow connections to sites with invalid SSL cers.","params":[{"name":"url","type":"String"},{"name":"options","default":"{}","type":"Object","text":"Options for fetch","properties":[{"name":"options.redirect","default":"manual","type":"Object","text":"\"manual\", \"follow\", or \"error\""},{"name":"options.maxRedirects","default":"20","type":"Object","text":"The maximum number of redirects that fetch will follow before returning an error.  Defaults to 20."},{"name":"options.acceptInvalidCerts","default":"20","type":"Object","text":"Set to true to allow connections to sites with invalid SSL cers."}]},{"name":"qsOptions","type":"String","text":"Options for serializing the request body using the qs package"}],"returns":[{"type":"Promise","text":""}]},"fetchLatest/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Creates a fetch function with an internal incrementing request counter that ensures that out of order\nresponses result in a StaleResponseError.\n\nExample usage:\n\n import { fetchLatest, StaleResponseError } from 'react-storefront/fetch'\n\n const fetch = fetchLatest()\n\n try {\n   const response = await fetch('/some/url')\n } catch (e) {\n   if (!StaleResponseError.is(e)) {\n     throw e // just ignore stale responses, rethrow all other errors\n   }\n }","params":[{"name":"fetch"}],"returns":[{"type":"Function","text":""}]},"fetchLatest/StaleResponseError":{"name":"StaleResponseError","type":"class","async":false,"generator":false,"comments":"Thrown when an out of order response is received","params":[],"returns":[],"members":[]},"format/price":{"name":"price","type":"function","async":false,"generator":false,"comments":"Formats a price for display","params":[{"name":"price","type":"Number"},{"name":"options","default":"{}","type":"Object","properties":[{"name":"options.currency","default":"'USD'"},{"name":"options.decimals","default":"2"},{"name":"options.locale","default":"'en-US'"}]}],"returns":[{"type":"String","text":""}]},"launchClient/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Bootstraps the PWA react application.","params":[{"name":"$0","type":"Object","properties":[{"name":"$0.App"},{"name":"$0.theme"},{"name":"$0.model"},{"name":"$0.router"},{"name":"$0.target","default":"document.getElementById('root')"},{"name":"$0.errorReporter","default":"Function.prototype"}]},{"name":"options","type":"options","properties":[{"name":"options.App","type":"React.Element","text":"The root app element"},{"name":"options.theme","type":"Object","text":"A material-ui theme"},{"name":"options.model","type":"Object","text":"A mobx-state-tree model class"},{"name":"options.target","type":"HTMLElement","text":"The DOM element to mount onto"}]},{"name":"errorReporter","type":"Function","text":"A function to call when an error occurs so that it can be logged"}],"returns":[]},"persist/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"import { persist } from 'path/to/persist'\n\n export const ModelName = types\n  .model('ModelName', {\n    keyOne: 'includeMe',\n    keyTwo: 'excludeMe'\n  })\n  .actions(self => ({\n    afterCreate() {\n      persist('storageName', self, {\n        keyOne: true,\n      })\n    }\n  }))","params":[{"name":"name","type":"String","text":"The name of the item in storage"},{"name":"store","type":"Model","text":"The mobx state tree model to store"},{"name":"schema","default":"{}","type":"Object","text":"OPTIONAL object of model keys, used to limit what gets stored - all keys stored by default"}],"returns":[]},"renderers/getJS":{"name":"getJS","type":"function","async":false,"generator":false,"comments":"Get javascript asset filename by chunk name","params":[{"name":"stats","type":"Object","text":"Webpack generated stats"},{"name":"chunk","type":"String","text":"Chunk name"}],"returns":[{"type":"String","text":"Asset filename"}]},"renderers/renderHtml":{"name":"renderHtml","type":"function","async":false,"generator":false,"comments":"Render HTML of given component","params":[{"name":"options","type":"options","properties":[{"name":"options.component","type":"React.Component","text":"Component to be rendered"},{"name":"options.providers","type":"Object","text":"Data providers"},{"name":"options.registry","type":"Object","text":"JSS Sheets Registry"},{"name":"options.theme","type":"Object","text":"MUI Theme"},{"name":"options.cssPrefix","default":"'jss'","type":"Object","text":"A prefix to apply to css classes"}]}],"returns":[{"type":"String","text":"HTML"}]},"renderers/renderInitialStateScript":{"name":"renderInitialStateScript","type":"function","async":false,"generator":false,"comments":"Renders initial state for client side hydration","params":[{"name":"options","type":"options","text":"Model instance","properties":[{"name":"options.state","type":"Object","text":"The initial app state needed for hydration"},{"name":"options.routeData","type":"Object","text":"The data that resulted from the route being run.  This is needed for creating a cache\n                                               entry for the equivalend .json request if the user navigates back to this page."},{"name":"options.defer","type":"Boolean","text":"Should defer execution"},{"name":"options.initialStateProperty","default":"'initialState'","type":"String","text":"Property name on window object"},{"name":"options.initialRouteDataProperty","default":"'initialRouteData'"}]}],"returns":[{"type":"String","text":"Script HTML"}]},"renderers/renderScript":{"name":"renderScript","type":"function","async":false,"generator":false,"comments":"Renders script for a specified chunk","params":[{"name":"src","type":"String","text":"Source of script"},{"name":"defer","type":"Boolean","text":"Should defer execution"}],"returns":[{"type":"String","text":"Script HTML"}]},"renderers/getScripts":{"name":"getScripts","type":"function","async":false,"generator":false,"comments":"Extracts scripts from sources in chunk","params":[{"name":"options","type":"Object","properties":[{"name":"options.stats","type":"Object","text":"Webpack generated stats"},{"name":"options.chunk","type":"String","text":"Chunk name"}]}],"returns":[]},"renderers/renderPrefetchHeader":{"name":"renderPrefetchHeader","type":"function","async":false,"generator":false,"comments":"Renders a link prefetch header value","params":[{"name":"src","type":"String","text":"Source of script"}],"returns":[]},"renderers/renderStyle":{"name":"renderStyle","type":"function","async":false,"generator":false,"comments":"Renders extracted CSS from Sheets Registry","params":[{"name":"options","type":"options","properties":[{"name":"options.registry","type":"Object","text":"JSS Sheets Registry"},{"name":"options.id","default":"'ssr-css'","type":"String","text":"ID for style tag"}]}],"returns":[{"type":"String","text":"Style HTML"}]},"renderers/render":{"name":"render","type":"function","async":false,"generator":false,"comments":"Renders a component on the server.","params":[{"name":"options","type":"options","properties":[{"name":"options.component","type":"React.Component","text":"Component to be rendered"},{"name":"options.state","type":"Object","text":"Model instance"},{"name":"options.theme","type":"Object","text":"MUI Theme"},{"name":"options.stats","type":"Object","text":"Webpack generated stats"},{"name":"options.clientChunk","type":"String","text":"Chunk name for hydration script"},{"name":"options.initialStateProperty","type":"String","text":"Optional window property name for initial state"},{"name":"options.injectAssets","default":"true","type":"Boolean","text":"Defaults to true.  Set this to false to prevent scripts and css from automatically being injected into the document."},{"name":"options.cssPrefix","type":"String","text":"A prefix to apply to css class names"}]}],"returns":[{"type":"Object","text":"Components for SSR"}]},"renderers/hydrate":{"name":"hydrate","type":"function","async":false,"generator":false,"comments":"Hydrates React component","params":[{"name":"options","type":"options","properties":[{"name":"options.component","type":"React.Component","text":"Component to be rendered"},{"name":"options.model","type":"Model","text":"MobX Model"},{"name":"options.theme","type":"Object","text":"MUI Theme"},{"name":"options.target","type":"String","text":"Selector for rendering target"},{"name":"options.providerProps","default":"{}","type":"String","text":"Props to add the to <Provider/> element"},{"name":"options.initialStateProperty","default":"'initialState'","type":"String","text":"Optional window property name for initial state"},{"name":"options.cssPrefix","default":"'jss'"}]}],"returns":[{"type":"Object","text":"The app state"}]},"withStyleProps/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Decorator for mapping a component's props to JSS styles","params":[{"name":"styles","type":"Object"},{"name":"options"}],"returns":[{"type":"React.Component","text":"Example: import withStyleProps from 'react-storefront'\n import React, { Component } from 'react'"}]},"model/AppModelBase/BreadcrumbModel":{"name":"BreadcrumbModel","type":"constant","async":false,"generator":false,"comments":"Represents a single breadcrumb","params":[],"returns":[]},"model/CartModelBase/default":{"name":"default","type":"constant","async":false,"generator":false,"comments":"A base model for the shopping cart","params":[],"returns":[]},"model/SearchModelBase/ResultsModel":{"name":"ResultsModel","type":"constant","async":false,"generator":false,"comments":"Represents an individual link within a group","params":[],"returns":[]},"model/SearchModelBase/ResultsGroupModel":{"name":"ResultsGroupModel","type":"constant","async":false,"generator":false,"comments":"Represents a group of links withing the search results","params":[],"returns":[]},"model/SearchModelBase/default":{"name":"default","type":"constant","async":false,"generator":false,"comments":"The base model for site-wide searches.","params":[],"returns":[]},"model/SearchResultsModelBase/FacetModelBase":{"name":"FacetModelBase","type":"constant","async":false,"generator":false,"comments":"A search facet that can be applied as a filter","params":[],"returns":[]},"model/SearchResultsModelBase/FacetGroupModelBase":{"name":"FacetGroupModelBase","type":"constant","async":false,"generator":false,"comments":"A grouping of facets","params":[],"returns":[]},"model/SearchResultsModelBase/SortBase":{"name":"SortBase","type":"constant","async":false,"generator":false,"comments":"A value by which results can be sorted","params":[],"returns":[]},"router/Router":{"name":"Router","type":"class","async":false,"generator":false,"comments":"Provides routing for MUR-based applications and PWAs.  This class is inspired by express and uses https://github.com/rcs/route-parser,\nwhich supports sophisticated pattern matching including optional paths, params, and splatting.\n\nExample:\n\n const router = new Router()\n\n router.get('/products/:id', ({ id }) => {\n   // fetch product from upstream API (you'll need to write this function)\n   return fetchProduct(id).then(result => {\n     return result.product // this will be the result of router.run()\n   })\n })\n\n // assuming env.path = /products/1 and env.method = 'GET'\n router.run() // => the details for product 1\n\nRoutes can be divided into multiple files to increase maintainability using the \"use()\" method.  For example:\n\n // /scripts/api/router.js\n\n const appShell = require('/build/index.html.js)\n\n module.exports = new Router()\n   .fallback(() => appShell) // render the PWA's app shell for all unmatched routes\n   .use('/products', require('/api/products.js'))\n\n // /scripts/api/products.js\n\n module.exports = new Router()\n   .get('/:id', ({ id }) => new Promise((resolve, reject) => {\n     // fetch product from upstream API...\n    }))\n\n // /scripts/index.js\n\n const router = require('/api/router')\n\n module.exports = function() {\n   // ...\n   router.run().then((result) => {\n     const body = typeof result === 'string' ? result : JSON.stringify(result)\n     sendResponse({ body, htmlparsed: true })\n   })\n }\n\nRouter is an EventEmitting that fires the following events:\n\nbefore: Fires before a route is run, passing an object containing request and response.\nafter: Fires after a route is run and all handlers have finised, passing an object containing request and response.\nfetch: Fires when a fromServer handler runs on the client, resulting in a fetch from the server. No arguments are passed to the event handler.","params":[],"returns":[],"members":[{"name":"get","type":"function","async":false,"generator":false,"comments":"Registers a GET route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"post","type":"function","async":false,"generator":false,"comments":"Registers a POST route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"patch","type":"function","async":false,"generator":false,"comments":"Registers a PATCH route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"put","type":"function","async":false,"generator":false,"comments":"Registers a PUT route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"delete","type":"function","async":false,"generator":false,"comments":"Registers a DELETE route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"options","type":"function","async":false,"generator":false,"comments":"Registers an OPTIONS route","params":[{"name":"path","type":"String","text":"A path pattern"},{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"fallback","type":"function","async":false,"generator":false,"comments":"Designates the handlers for unmatched routes","params":[{"name":"handlers"},{"name":"callback","type":"Function","text":"A function that returns a promise that resolves to the content to return"}],"returns":[{"type":"Router","text":"this"}]},{"name":"appShell","type":"function","async":false,"generator":false,"comments":"Defines the handler for the app-shell.  Generally this should be a single fromServer handler that return\nthe global data for menus and navigation and sets loading: true.  The app-shell is used in offline mode\nduring initial landing on an uncached SSR result.","params":[{"name":"handlers","type":"any","text":"Handlers that return patches to be merged into the app state"}],"returns":[{"type":"Router","text":"this"}]},{"name":"isAppShellConfigured","type":"function","async":false,"generator":false,"comments":"Returns true if appShell has been called to configure an appShell route, otherwise false.","params":[],"returns":[{"type":"Boolean","text":""}]},{"name":"error","type":"function","async":false,"generator":false,"comments":"Sets the handler for errors thrown during route handling","params":[{"name":"handler","type":"Function","text":"A function that returns a promise that resolves to the content to return"}],"returns":[{"type":"Router","text":"this"}]},{"name":"use","type":"function","async":false,"generator":false,"comments":"Registers a set of nested routes.\n\nExample:\n\n Router root = new Router()\n\n Router products = new Router()\n products.get('/:id', ({ id }) => {\n   return Promise.resolve(id)\n })\n\n root.use('/products', products)\n\n // url: /products/1\n root.run().then(result => console.log(result)) // => 1","params":[{"name":"path","type":"String","text":"The parent path"},{"name":"router","type":"Router","text":"A router to handle the nested routes"}],"returns":[{"type":"Router","text":"this"}]},{"name":"configureClientCache","type":"function","async":false,"generator":false,"comments":"Configures service worker runtime caching options","params":[{"name":"options","type":"Object","properties":[{"name":"options.cacheName","type":"Object","text":"The name of the runtime cache"},{"name":"options.maxEntries","type":"Object","text":"The max number of entries to store in the cache"},{"name":"options.maxAgeSeconds","type":"Object","text":"The TTL in seconds for entries"}]}],"returns":[{"type":"Router","text":"this"}]},{"name":"getCacheKey","type":"function","async":false,"generator":false,"comments":"Gets the server cache key for the matching route.","params":[{"name":"request","type":"Object"},{"name":"defaults","type":"Object","text":"The default values used for the cache key"}],"returns":[{"type":"Object","text":"An object populate with keys and values that when hashed, make up the cache key"}]},{"name":"createLocation","type":"function","async":false,"generator":false,"comments":"Creates an object describing the browser location","params":[],"returns":[{"type":"Object","text":""}]},{"name":"run","type":"function","async":true,"generator":true,"comments":"Runs the current url (from env) and generates a result from each the matching route's handlers.","params":[{"name":"request","type":"Object","text":"The request being served","properties":[{"name":"request.path","type":"String","text":"The url path"},{"name":"request.method","type":"String","text":"The http method"}]},{"name":"response","type":"Response","text":"The response object"},{"name":"options","default":"{}","type":"Object","properties":[{"name":"options.initialLoad","default":"false","type":"Boolean","text":"Set to true if this is the initial load of the application.  This will cause the HTML to be cached for the current path"},{"name":"options.historyState","default":"{}"}]}],"returns":[{"type":"Object","text":"Generates state objects"}]},{"name":"runAll","type":"function","async":true,"generator":false,"comments":"Runs all client and server handlers for the specified path and method","params":[{"name":"request","type":"Object","text":"The request being served","properties":[{"name":"request.path","type":"String","text":"The url path"},{"name":"request.method","type":"String","text":"The http method"}]},{"name":"response","type":"Response","text":"The response object"},{"name":"options","type":"Object"},{"name":"state","default":"{}","type":"Object","text":"The accumulated state from other handlers"}],"returns":[{"type":"Object","text":"The merged result of all handlers"}]},{"name":"toPromise","type":"function","async":false,"generator":false,"comments":"Converts specified callback to a promise","params":[{"name":"callback","type":"Function/Object","text":"A function that returns a Promise that\n resolves to the new state, a function that returns the new state, or the new state itself."},{"name":"params","type":"Object","text":"The request parameters"},{"name":"request","type":"Object","text":"The request object with body and headers"},{"name":"response","type":"Response","text":"The response object"}],"returns":[]},{"name":"findMatchingRoute","type":"function","async":false,"generator":false,"comments":"Returns the matching route and parsed params for the specified path and method","params":[{"name":"request","type":"Object","text":"The http request"}],"returns":[{"type":"Object","text":"an object with match and params"}]},{"name":"willNavigateToUpstream","type":"function","async":false,"generator":false,"comments":"Returns true if the URL points to a route that has a proxyUpstream handler.","params":[{"name":"url","type":"String","text":"The url to check"},{"name":"method","default":"'get'","type":"String"}],"returns":[{"type":"Boolean","text":""}]},{"name":"fetchFreshState","type":"member","async":false,"generator":false,"comments":"Runs all client and server handlers for the specified location and returns state","params":[{"name":"location"}],"returns":[]},{"name":"onLocationChange","type":"member","async":false,"generator":false,"comments":"Called when the location is changed on the client","params":[{"name":"callback","type":"Function","text":"A callback to pass the new state to"},{"name":"location","type":"Object","text":"The new location"},{"name":"action"}],"returns":[]},{"name":"watch","type":"function","async":false,"generator":false,"comments":"Calls the specified callback whenever the current URL changes","params":[{"name":"history","type":"History"},{"name":"callback","type":"Function"}],"returns":[{"type":"Router","text":"this"}]},{"name":"applySearch","type":"function","async":false,"generator":false,"comments":"Provides an easy way to navigate by changing some but not all of the query params.  Any keys\nincluded in the params object are applied as new query param values.  All other query params are preserved.","params":[{"name":"params","type":"Object","text":"Key/value pairs to apply to the query string.  Specifying a value of undefined or null will remove that parameter from the query string"},{"name":"stringifyOptions","default":"{}","type":"Object","text":"Options of stringifying all query params.  Applied for qs.stringify: https://github.com/ljharb/qs#stringifying"}],"returns":[]}]},"router/cache/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Specifies that the result of a route should be cached.  This handler must come before fromServer.\n\nExample:\n\n   router.get('/p/:id',\n     cache({\n       server: {\n         maxAgeSeconds: 300 // cache for 5 minutes on the server,\n         key: (request, defaults) => ({ // cache result separately for mobile and desktop user agents\n           ...defaults,\n           mobile: 'iOS', 'Android'.includes(\n             new UAParser(request.headers'user-agent').getOS().name\n           )\n         })\n       },\n       client: true // cache in the service worker based on the settings passed to router.configureClientCache()\n     })\n     fromClient({ view: 'Product' }),\n     fromServer('./product.js'),\n   )","params":[{"name":"options","type":"Object","properties":[{"name":"options.server","type":"Number","properties":[{"name":"options.server.maxAgeSeconds","type":"Number","text":"The number of seconds the result should be cached on the server.  The maxAgeSeconds key is required when specifying a server config."},{"name":"options.server.key","type":"Function","text":"A function to compute a custom cache key for server-side caching.  The function is\n passed the request object and a defaults object containing the key/value pairs that make up the default cache key.  This function is optional when specifying a server config."}]},{"name":"options.client","type":"Boolean","text":"Set to true to cache on the client based on the configuration defined by router.configureClientCache(). Defaults to false."}]}],"returns":[{"type":"Object","text":""}]},"router/fromClient/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"A handler that can be run on the client.  It will also be run on the server during server-side rendering.\n\nExample:\n\n\trouter.get('/p/:id',\n\t\tfromClient({ view: 'Product' }),\n\t\tfromServer('./product')\n\t)","params":[{"name":"callback","type":"Function/Object","text":"A function that takes the route params and returns an object to spply to the app state, or simply an object to spply to the app state."}],"returns":[{"type":"Object","text":"A handler spec"}]},"router/fromServer/fetch":{"name":"fetch","type":"function","async":true,"generator":false,"comments":"Fetch's state as json from the specified url","params":[{"name":"url","type":"String","text":"The url to fetch"},{"name":"options","default":"{}","type":"Object","properties":[{"name":"options.cache","default":"'default'","type":"String","text":"Set to \"force-cache\" to cache the response in the service worker.  Omit to skip the service worker cache."}]}],"returns":[{"type":"Object","text":"A state patch"}]},"router/fromServer/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Creates a handler that fetches data from the server.\n\nThe handlerPath should point to a module that exports a function that takes params, request, and response,\nand returns an object that should be applied to the app state.  For example:\n\n // routes.js\n router.get('/p/:id'\n   fromServer('./product/product-handler')\n )\n\n // product/product-handler.js\n export default function productHandler(params, request, response) {\n   return fetchFromUpstreamApi(/products/${params.id})\n     .then(res => res.json())\n     .then(productData => ({ // the shape of this object should match your AppModel\n       page: 'Product',\n       product: productData\n     }))\n }\n\nWhen the request path ends in \".json\", the json response will be returned verbatim.  In all other cases, server-side rendered HTML\nwill be returned.\n\nYou can also send a verbatim string response using response.send(body).  For example:\n\n // routes.js\n router.get('/my-api'\n   fromServer('./my-api-handler')\n )\n\n // my-api-handler.js\n export default function myApiHandler(params, request, response) {\n   response\n     .set('content-type', response.JSON)\n     .send(JSON.stringify({ foo: 'bar' }))\n }\n\nWhen response.send() is called in a handler, react-storefront will never perform server-side rendering.","params":[{"name":"handlerPath","type":"String","text":"The path to the module that exports a handler function that returns state to apply"},{"name":"getURL","type":"Function","text":"An optional function that returns the back end url to call when fetching.  You only need\n  to specify this if you want to override the default URL."}],"returns":[{"type":"Function","text":""}]},"router/headers/SURROGATE_KEY":{"name":"SURROGATE_KEY","type":"string","async":false,"generator":false,"comments":"Response header which designates an surrogate key by which the response can be\nflushed from edge caches.\n\nValue: a string, defaults to the handler path but can be set by the user.","params":[],"returns":[]},"router/headers/HANDLER":{"name":"HANDLER","type":"string","async":false,"generator":false,"comments":"Response header containing the path to the handler as written in fromServer\n\nValue: a string like './home/home-handler'","params":[],"returns":[]},"router/headers/RESPONSE_TYPE":{"name":"RESPONSE_TYPE","type":"string","async":false,"generator":false,"comments":"Response header that indicates whether the response was \"static\", \"json\", \"ssr\", or \"proxy\".\nUsed to gather metrics for different response types.\n\nValue: \"static\", \"json\", \"ssr\", or \"proxy\"","params":[],"returns":[]},"router/headers/API_VERSION":{"name":"API_VERSION","type":"string","async":false,"generator":false,"comments":"Response header used by the service worker to ensure that responses are only served from the\ncache  corresponding to the current running version of the app.\n\nValue: a webpack hash","params":[],"returns":[]},"router/headers/REACT_STOREFRONT":{"name":"REACT_STOREFRONT","type":"string","async":false,"generator":false,"comments":"Response header whose presence indicates that the request was\nserved by react-storefront.\n\nValue: true","params":[],"returns":[]},"router/headers/XDN_VERSION":{"name":"XDN_VERSION","type":"string","async":false,"generator":false,"comments":"Request header sent from the outer edge to indicate that the app is running\nbehind an outer edge.\n\nValue: a semver value.","params":[],"returns":[]},"router/headers/ROUTES":{"name":"ROUTES","type":"string","async":false,"generator":false,"comments":"Request header that when present will make RSF return a JSON summary of the routes.","params":[],"returns":[]},"router/proxyUpstream/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"A handler that fetches HTML from the same path as the current request on the upstream site. Use\nthis handler to transform HTML from the upstream site or return it unaltered.\n\nThe callback you provide is passed the following arguments:\n\nparams {Object} Request parameters parsed from the route and query string\nrequest {Object} An object representing the request\nresponse {Response} An object representing the response.  Call response.send(html) to send the resulting html back to the browser.\n\nTo use response from the upstream site unaltered, called response.send() with no arguments.","params":[{"name":"cb","default":"perfectProxy","type":"Function","text":"A callback which takes params, request, and response."}],"returns":[]},"router/serviceWorker/cache":{"name":"cache","type":"function","async":true,"generator":false,"comments":"Cache content using the service worker.  If content is not supplied, the service worker will fetch\nthe content from the server","params":[{"name":"path","type":"String","text":"The URI path of the request"},{"name":"cacheData","type":"String","text":"The data to cache"}],"returns":[]},"router/serviceWorker/prefetchJsonFor":{"name":"prefetchJsonFor","type":"function","async":true,"generator":false,"comments":"Prefetches and caches JSON for the specified path","params":[{"name":"path","type":"String","text":"A URL path for a page (without .json)"},{"name":"includeSSR"}],"returns":[]},"router/serviceWorker/prefetch":{"name":"prefetch","type":"function","async":false,"generator":false,"comments":"Prefetches and caches SSR and JSON for the specified path","params":[{"name":"path","type":"String","text":"A URL path for a page (without .json)"}],"returns":[]},"router/serviceWorker/abortPrefetches":{"name":"abortPrefetches","type":"function","async":true,"generator":false,"comments":"Aborts all in progress prefetches.  Call this function to prevent prefetching from blocking\nmore important requests, like page navigation.","params":[],"returns":[]},"router/serviceWorker/resumePrefetches":{"name":"resumePrefetches","type":"function","async":true,"generator":false,"comments":"Resume queued prefetch requests which were cancelled to allow for more important requests","params":[],"returns":[]},"router/serviceWorker/configureCache":{"name":"configureCache","type":"function","async":true,"generator":false,"comments":"Configures runtime caching options","params":[{"name":"options","type":"Object","properties":[{"name":"options.cacheName","type":"Object","text":"The name of the runtime cache"},{"name":"options.maxEntries","type":"Object","text":"The max number of entries to store in the cache"},{"name":"options.maxAgeSeconds","type":"Object","text":"The TTL in seconds for entries"}]}],"returns":[]},"router/serviceWorker/waitForServiceWorkerController":{"name":"waitForServiceWorkerController","type":"function","async":true,"generator":false,"comments":"Resolves when the service worker has been installed","params":[],"returns":[]},"router/serviceWorker/removeOldCaches":{"name":"removeOldCaches","type":"function","async":true,"generator":false,"comments":"Removes runtime caches for old versions of the api.  This ensures that all responses\nare appropriate for the current version of the UI.","params":[],"returns":[]},"router/withGlobalState/default":{"name":"default","type":"function","async":true,"generator":false,"comments":"When doing SSR, returns globalState and localState merged.  When responding to an AJAX\nrequest, only returns localState.\n\nExample:\n\n function productHandler({ id }, state, request) {\n   const product = {} // get product info from upstream API\n   const globalState = () => fetchMenuData() // async function that makes an api call to get menu data.  Will only be called during ssr\n   return withGlobalState(request, globalState, product)\n }","params":[{"name":"request","type":"Object","text":"The request object passed into the handler"},{"name":"globalState","type":"Object/Function","text":"An object containing data that is needed for all landing pages, such as menu items, navigation, etc..., or a function that returns this data."},{"name":"localState","type":"Object","text":"The state being returned for the specific URL being handled"}],"returns":[{"type":"Object","text":""}]},"utils/browser/isSafari":{"name":"isSafari","type":"function","async":false,"generator":false,"comments":"Returns true only in Safari","params":[],"returns":[{"type":"Boolean","text":""}]},"utils/createGenerateClassName/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Creates a class name generator for JSS.\nAdapted from https://github.com/cssinjs/jss/blob/master/src/utils/createGenerateClassName.js","params":[{"name":"amp","default":"false","type":"Boolean","text":"Set to true when rendering amp.  When true, the smaller production class names will be used so\n you can tell for sure whether or not your stylesheet is small enough to meet amp's size limit.","properties":[{"name":"amp.amp","default":"false"}]}],"returns":[{"type":"Function","text":""}]},"utils/dataProps/default":{"name":"default","type":"function","async":false,"generator":false,"comments":"Returns an object containing the values from props corresponding to keys that start with \"data-\"","params":[{"name":"props","type":"Object"}],"returns":[{"type":"Object","text":""}]},"utils/scriptInjector/injectScriptInHead":{"name":"injectScriptInHead","type":"function","async":false,"generator":false,"comments":"Method for injecting script tag in <head>","params":[{"name":"src","type":"String","text":"path to script"},{"name":"params","default":"{}","type":"Object","text":"Optional params","properties":[{"name":"params.attrs","default":"{}","type":"Object","text":"Optional attributes to add to element"},{"name":"params.once","default":"true","type":"Boolean","text":"If true then script will be injected only once"}]}],"returns":[{"type":"Promise","text":"Promise returns on script's onload event"}]},"utils/scriptInjector/injectCodeInHead":{"name":"injectCodeInHead","type":"function","async":false,"generator":false,"comments":"Method for injecting target code in <head>","params":[{"name":"code","type":"String","text":"script code"},{"name":"params","default":"{}","type":"Object","text":"optional params","properties":[{"name":"params.once","default":"false","type":"Boolean","text":"If true then script will be injected only once"}]}],"returns":[]},"utils/scriptInjector/removeScriptInHead":{"name":"removeScriptInHead","type":"function","async":false,"generator":false,"comments":"Method for removing script in <head>","params":[{"name":"src","type":"String","text":"path to script"}],"returns":[]},"utils/scriptInjector/removeCodeInHead":{"name":"removeCodeInHead","type":"function","async":false,"generator":false,"comments":"Method for removing code  in <head>","params":[{"name":"code","type":"String","text":"script code"}],"returns":[]},"utils/state/lazyState":{"name":"lazyState","type":"function","async":false,"generator":false,"comments":"If the provided object is a string, returns a function that parses the string as JSON,\notherwise returns the provided object.","params":[{"name":"state"}],"returns":[{"text":""}]},"utils/state/parseState":{"name":"parseState","type":"function","async":false,"generator":false,"comments":"If the provided object is a string, parses it as JSON and returns the resulting object,\notherwise returns the provided object.","params":[{"name":"state"}],"returns":[{"type":"Object","text":""}]},"utils/url/relativeURL":{"name":"relativeURL","type":"function","async":false,"generator":false,"comments":"Strips the protocol and hostname from the URL, returning a relative URL.\n\nExample:","params":[{"name":"url","type":"String","text":"An absolute or relative URL"}],"returns":[{"type":"String","text":"A relative URL"}]},"utils/url/absoluteURL":{"name":"absoluteURL","type":"function","async":false,"generator":false,"comments":"Creates an absolute URL for the given URL","params":[{"name":"url","type":"String","text":"A relative URL"},{"name":"currentLocation","default":"{}","type":"LocationModel","text":"The current browser location","properties":[{"name":"currentLocation.protocol"},{"name":"currentLocation.hostname"},{"name":"currentLocation.port"},{"name":"currentLocation.pathname"}]}],"returns":[{"type":"String","text":"An absolute URL"}]},"utils/url/canUseClientSideNavigation":{"name":"canUseClientSideNavigation","type":"function","async":false,"generator":false,"comments":"Returns true if a URL can be navigated to on the client using history.push","params":[{"name":"url","type":"String","text":"The URL to check"},{"name":"router","type":"String","text":"The router"}],"returns":[{"type":"Boolean","text":""}]}}};
export default data;